<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>中秋</title>
      <link href="/2025/10/07/%E4%B8%AD%E7%A7%8B/"/>
      <url>/2025/10/07/%E4%B8%AD%E7%A7%8B/</url>
      
        <content type="html"><![CDATA[<p>2025&#x2F;10&#x2F;6，中秋节，在奶奶家（虽然奶奶走了，但我还是习惯那么称呼）吃晚饭。<br>&emsp;&emsp;可能有的人已经知道了，我很喜欢中秋节。<br>&emsp;&emsp;在小学一二年级的时候，我幸运地被选为了中秋活动中后羿的扮演者，而刚好嫦娥是那时候很多男生都喜欢的对象。我从家里拿来了珍藏的弓箭和宝剑，前者是射下九日的救世主，后者是嫦娥离开的指使者。<br>&emsp;&emsp;“嫦娥，我的嫦娥！” 这是我唯一记得的台词。<br>&emsp;&emsp;我射下九日，救了人类。<br>&emsp;&emsp;帝俊恨我杀了其子，剥夺了我的神格。<br>&emsp;&emsp;王母娘娘又赐我一颗仙丹，吃了可使人长生不老，飞升成仙。但只有一枚，我暂时不知如何分配。<br>&emsp;&emsp;百姓爱戴我，嫦娥对他们也很好。我收了个徒弟，叫逄蒙。他天赋老好了，我打算好好培养他。<br>&emsp;&emsp;不知道他是怎么仙丹的事的，人一旦被欲望支配了，可就算不得人了。<br>&emsp;&emsp;他，他竟然趁我不在拿着宝剑威胁嫦娥把仙丹交出来！<br>&emsp;&emsp;娘子她为了我们，以及不让逄蒙得逞，把仙丹吞下了……<br>&emsp;&emsp;她飞到月亮上了，放到那广寒宫。广寒宫，一定很冷吧…但那里有玉兔，娘子也不会太孤单。<br>&emsp;&emsp;我没了仙丹，肉体无法飞往那广寒宫，但灵魂早就不在地面了。逄蒙如何，对我也无用。<br>&emsp;&emsp;和我后来的经历很像呢。<br>&emsp;&emsp;那次，我第一次感觉我是主角，是剧中的，亦是现实中的。<br>&emsp;&emsp;我有了这份信心，后面也是积极向上越来越好了。日月交错，后羿落在地上的那滴泪水，在我心中埋下了对中秋节特殊的情感。</p><p>&emsp;&emsp;其次，是读了苏轼的《水调歌头》。其实第一次听，是听到那首歌。能把一首词唱成歌，仿佛是在北宋感受曲与词一般，加上其全篇无太华丽的字眼却处处充满美感的诗句，以及隐隐就能感受到的一缕情丝，我便对《水调歌头》、苏轼以及中秋节产生了独特的情感。借这首词来给大家解释一下我对中秋节的情感吧。<br>&emsp;&emsp;“明月几时有，把酒问青天。” 开篇一句话就引起了我的共鸣。今晚的月亮，是我印象最深刻的第三轮明月。每当中秋节，每个中国人都或多或少会抬起头，共同望向那轮唯一的月亮<br>&emsp;&emsp;——此时此刻，你也在看吧？我们在同一片夜空下，共赏同一轮明月，眼中都有着同样的倒影。我们的目光在同一个地方，嫦娥会把我们的思念交换，那是不是就相当于你望着我，我望着你呢？光线也是能反射的，对吧？那我把我的情感寄托在月亮上，你是不是也能感受到呢？<br>&emsp;&emsp;这是穿越空间。月亮还能穿越时间。<br>&emsp;&emsp;所谓“秦时明月汉时关”，这轮明月与2000年前没有什么不同，无论何时何地相望，即使你不在我身边，思念都能够传达吧，毕竟光的传播也需要时间呢。（这些想法去年已有，详看配图）<br>&emsp;&emsp;“不知天上宫阙，今夕是何年。”天上一天，地上一年。织女可能只在天上度了一日，而牛郎需要三百多天才能等到鹤桥；嫦娥不知在广寒宫上陪玉兔等了多久，换来与后羿一年在中秋节才能的一次相望。在情感的加持下，每个人对时间流逝的速度都有不同的感觉吧。<br>&emsp;&emsp;“我欲乘风归去，又恐琼楼玉宇，高处不胜寒。”人间太多喧嚣，即使是豁达的苏轼也会有所疲倦吧。谁没有想过乘上一缕清风，飞往那飘渺的仙境呢？但仙境毕竟飘渺，那么高的地方，我带着人世的尘土，岂不会玷污了那“琼楼玉宇”？那么高的地方，我们这凡人之躯，一定会很冷吧。上面也没啥人，心里估计也是冰冰的。<br>&emsp;&emsp;“起舞弄清影，何似在人间。”话又说了回来，苏轼还是很开朗的。这人间的红尘未必非断不可，能在月光下翩翩起舞，不顾旁人的目光，既有尘世的乐趣，亦有仙境的自由，岂不美哉？这就是苏轼与王维的“佛系”、与他人不媚世俗的区别，他的乐观能让他继续享受生活，什么东坡肉、羊蝎子、西湖的，这人间不比天上好？<br>&emsp;&emsp;“转朱阁，低绮户，照无眠。”好吧，虽然想了那么多，但我和苏轼一样，都是一个人。月光转过朱红楼阁，低低地挂在雕花窗户上，冷冷地照在躺在床上对着手机发呆的我。没有消息，没有红点，有的只是发不出去的草稿，以及“对方还不是你的朋友”。苏轼也在想自己的弟弟吧。<br>&emsp;&emsp;“不应有恨，何时长向别时圆？”没人能怪，也不想怪自己的无能，只能怪那月亮了。都说中秋节团圆，那为什么只有中秋节才能团圆呢？是不是就是月亮导致的！😤而且，这么个团圆的日子都没法和你在一起，肯定是月亮嫉恨我，让我在满月的时候离别！我又不是狼王，满月有啥不行的。<br>&emsp;&emsp;“人有悲欢离合，月有阴晴圆缺，此事古难全。”哎呀，也不能全怪月亮，再emo一下吧。这人的一生呐，就如月相一样，阴晴圆缺、悲欢离合，变化都是自然的、甚至是有规律的，若一直都是一轮满月挂在夜空，谁还会珍惜她？如果你能一直在我身边，我可能也会没那么想你了。但是，有离也必有合啊，这也代表等到下个满月，我们一定能重逢的，对吧！这种变迁如何才能令人满意，自嫦娥上去后就是个问题啊。<br>&emsp;&emsp;“但愿人长久，千里共婵娟。”我靠，传世神句。唉，只希望人们能够平安长久，就算相隔千里，普照众生的月光也会把我们联系在一起吧！哈哈哈，原来苏轼的观念和我一样啊，看来在我望向月亮的时候，苏轼也一定在赏月吧！苏轼，我说你啊，你个小傻瓜，那么豁达个人，干嘛一直跟官场耗着呢？我才不是觉得你跟我像才会担心你这样没前途呢！祝你和你弟弟能团圆吧，海南不再会是终点了…<br>&emsp;&emsp;苏轼真的是个很乐观的人，并且不是那种摒弃欲望的乐观，而是保持对生活的热爱。之后我再好好讲讲他吧，毕竟这里我才是主角，可不能被他抢了。<br>&emsp;&emsp;这首词对我影响很深，我此后写最爱的节日也必是中秋，（最爱的季节是秋，最爱的花是菊）。虽然月饼不是特别好吃，但芙蓉和冰皮也还是可以，除了那反人类的五仁。我以前并不是很理解传统习俗，但这个节日能让很久未见的人相遇，已经有很大意义了。在月亮底下吃个月饼倒也无所谓，我可不怕长胖！<br>&emsp;&emsp;虽然深圳的亚热带季风气候注定不会有多么秋高气爽，但中秋的时候至少也会凉快点；虽然没有红枫落叶，但也有萧瑟的秋雨（其实是台风啦…）；我还有月亮和你呢！</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
            <tag> 中秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC424F题解</title>
      <link href="/2025/09/21/ABC424F%E9%A2%98%E8%A7%A3/"/>
      <url>/2025/09/21/ABC424F%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>考完 CSP，估分 J 97，S 87。<br>在红岭吃午餐的时候，qx 跟我说他今晚不打 ABC，结果他偷偷背着我打了，还进了前 1000 名，已经上 1000 分了。orz orz<br>幸好我也打了，名次刚好比他高 9 个，也上 1000 分。还剩 10 分钟已经看出来 F 是线段树了，但觉得太耗时间了想着用 set 偷懒，没写出来。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/7e771jbo.png?x-oss-process=image/resize,m_lfit,h_340,w_450" alt="abc.webp"><br>To 线段树:<br>&emsp;&emsp;看到你我很激动，我已经很久没遇到你了。但我又没时间了……<br>To yl​:<br>&emsp;&emsp;不怪你，下次我们再相遇吧，这次离别只是为了更好的重逢，等我再遇到你时希望你已经是一个合格的OIer了。见字如面。<br>​<br>​线段树，除了你还有哪个数据结构愿意陪我吵，陪我闹，陪我伤心陪我笑……我已经没有朋友了……</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>一个圆上有 $N$ 个间隔相等的点，$Q$ 次询问，每次询问要求你画出端点为 $A$ 和 $B$ 的弦，如果和之前画出的弦相交则输出 No 并不画。<br>保证每个 $A$ 和 $B$ 都<strong>不相等</strong>。</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>不知道为什么，一眼线段树。<br>先来看官方给的图。<br><img src="https://img.atcoder.jp/abc424/da7d251baf0dbd538951f53fa04bb155.png" alt="eg"><br>已有 $(1,5)$ 这条弦，我们该如何判断当前这条弦不会跟其相交呢？<br>不妨令 $A &lt; B$，可以看到弦把圆分成了 $2$ 部分，如果新的弦和这条弦相交的话，必定是从一个部分到另一个部分。那我们可以顺时针来看，让弦 $(A,B)$ 对应区间 $[A,B]$，如果区间内有点和区间外的点有连线，那么就相交了。<br>形式化的，由于弦的端点各不相同：</p><ul><li>如果区间 $[A,B]$ 内有点的对应端点是小于 $A$ 或大于 $B$ 的，那么这条弦就和之前的弦相交。</li><li>否则的话，我们就连上 $A,B$，$A$ 对应 $B$，$B$ 对应 $A$。</li></ul><p>那有单点修改，区间查询，我们该如何维护这个对应端点呢？<br>线段树。维护区间的最小值和最大值。甚至不用写懒惰标记</p><ul><li>单点修改：把 $A$ 点的值改成 $B$，$B$ 点的值改成 $A$</li><li>区间查询：获取 $[A,B]$ 内的最小值、最大值，并判断是否小于 $A$ 或大于 $B$</li></ul><p>细节在代码注释里了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls o&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs o&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+5</span>,inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> mn,mx;</span><br><span class="line">    node <span class="keyword">operator</span> +(<span class="type">const</span> node &amp;w)<span class="type">const</span>&#123;<span class="keyword">return</span> &#123;<span class="built_in">min</span>(mn,w.mn),<span class="built_in">max</span>(mx,w.mx)&#125;;&#125;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> o)</span></span>&#123;tr[o]=tr[ls]+tr[rs];&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[o]=&#123;l,l&#125;;<span class="comment">//一开始让端点对应自己</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updmn</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">int</span> x)</span></span>&#123;<span class="comment">//改最小</span></span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[o].mn=<span class="built_in">min</span>(tr[o].mn,x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid) <span class="built_in">updmn</span>(ls,l,mid,pos,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">updmn</span>(rs,mid<span class="number">+1</span>,r,pos,x);</span><br><span class="line">    <span class="built_in">pushup</span>(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updmx</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">int</span> x)</span></span>&#123;<span class="comment">//改最大</span></span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[o].mx=<span class="built_in">max</span>(tr[o].mx,x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid) <span class="built_in">updmx</span>(ls,l,mid,pos,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">updmx</span>(rs,mid<span class="number">+1</span>,r,pos,x);</span><br><span class="line">    <span class="built_in">pushup</span>(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;<span class="comment">//模板查询</span></span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) <span class="keyword">return</span> tr[o];</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    node res=&#123;inf,-inf&#125;; </span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) res=res+<span class="built_in">query</span>(ls,l,mid,L,R);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) res=res+<span class="built_in">query</span>(rs,mid<span class="number">+1</span>,r,L,R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a,b); </span><br><span class="line">        node k=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,a,b);</span><br><span class="line">        <span class="keyword">if</span>(k.mn&lt;a||k.mx&gt;b) cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">            <span class="built_in">updmn</span>(<span class="number">1</span>,<span class="number">1</span>,n,b,a);</span><br><span class="line">            <span class="built_in">updmx</span>(<span class="number">1</span>,<span class="number">1</span>,n,a,b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> 题解 </tag>
            
            <tag> 信息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC423小丑回忆录</title>
      <link href="/2025/09/16/ABC423%E5%B0%8F%E4%B8%91%E5%9B%9E%E5%BF%86%E5%BD%95/"/>
      <url>/2025/09/16/ABC423%E5%B0%8F%E4%B8%91%E5%9B%9E%E5%BF%86%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>2025&#x2F;9&#x2F;16 我不知道自己选择的道路是否正确</p><hr><p>继ABC420写出来6题之后，我接连两次只写出来3题——一次是题目是在太狗屎，一次是我太自大太懒惰加上有点心事了。<br>ABC423，做出来4题——不是ABCD，而是ABCE，那么D题呢？<br>我是小丑，读错题+忘记优先队列默认是大根堆了，嘿嘿嘿。</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><a href="https://atcoder.jp/contests/abc423/tasks/abc423_d">原题</a></p><h4 id="DeepL翻译（我自己读的时候有点坑）"><a href="#DeepL翻译（我自己读的时候有点坑）" class="headerlink" title="DeepL翻译（我自己读的时候有点坑）"></a>DeepL翻译（我自己读的时候有点坑）</h4><p>有一家餐厅最多可同时接待 $K$ 位顾客。餐厅前面有一条小路，小路上有一条排队通道。</p><p>在时间 $0$ 时，餐厅内没有顾客，排队队伍也是空的。</p><p>今天，有 $N$ 组顾客预定前来就餐，他们按照到达的先后顺序被编号为从 $1$ 到 $N$ 。 $i$ 组由 $C_i$ 人组成，在 $A_i$ 时进入队列末尾，并在进入餐厅后的 $B_i$ 个时间单位离开餐厅。</p><p>每个群体都是在同时满足以下两个条件的最早时间离开队列进入餐厅的：</p><ul><li>该组位于队列前列。换句话说，该组是当时仍在排队的人中最早加入的一组。</li><li>将该组人数与餐厅内所有当前排队的人数(包括在该时间段进入餐厅的人数，不包括离开餐厅的人数)相加，人数为 $K$ 或更少。</li></ul><p>求每组人进入餐厅的时间。</p><p>自己读题去吧，这题难点就是读懂题目。除此之外没啥难的，纯粹是我脑子不好。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我好像做过类似的题，但好像又没什么印象，所以对我来说算是模拟题。<br>首先，想到暴力的方法——枚举每时每刻，但 $A,B\leq10^7$ 所以不太行。<br>（不对啊我靠，不会 1e7 可以吧？啊？我又想复杂了。没事，我这个方法无论 $A,B$ 的大小。）</p><p>但并不是每个时间都是有用的，就像身边的人一样。我曾幻想与每个人交好，现在看来只留一些有价值的即可。<br>显然，有价值的点就是每组顾客进出的时间——只有 $2N$，可以接受。<br>那我们就开一个存事件的优先队列，先把每一组顾客进队放进优先队列中（记得默认是大根堆！！！），按时间取出来。接下来分类讨论进队和出餐厅的操作：</p><ul><li>对于入队操作<ul><li>如果当前餐厅容得下你，就放进去，并且将出餐厅的操作（是 $time+b_{id}$ ！）加入到事件中。你进餐厅的时间就是入队时间。</li><li>容不下你的话，维护一个队列排队，然后你进去等着别人来处理吧。</li></ul></li><li>对于出餐厅的操作，直接将当前餐厅人数减掉。由于人数变少了，有的排队的人也该进来了，那就一直让排队的人进来，直到塞不下了。那每一个出队的进餐厅的时间就是当前的时间，并且再把这一组顾客出餐厅加入事件中。</li></ul><p>然后就没了，真的没什么难的。<br>我真的是傻子。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,k,a[N],b[N],c[N],ans[N],sum;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> type,time,id; </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node&amp;w)<span class="type">const</span>&#123;<span class="keyword">return</span> time&gt;w.time;&#125;<span class="comment">//默认大根堆！！！</span></span><br><span class="line">&#125;; </span><br><span class="line">priority_queue&lt;node&gt; mk; </span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];</span><br><span class="line">        mk.<span class="built_in">push</span>(&#123;<span class="number">0</span>,a[i],i&#125;);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">while</span>(!mk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> type=mk.<span class="built_in">top</span>().type,time=mk.<span class="built_in">top</span>().time,id=mk.<span class="built_in">top</span>().id;</span><br><span class="line">        mk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(type)&#123;</span><br><span class="line">            sum-=c[id];</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;sum+c[q.<span class="built_in">front</span>()]&lt;=k)&#123;</span><br><span class="line">                <span class="type">int</span> i=q.<span class="built_in">front</span>();</span><br><span class="line">                sum+=c[i],ans[i]=time,mk.<span class="built_in">push</span>(&#123;<span class="number">1</span>,time+b[i],i&#125;);</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum+c[id]&lt;=k&amp;&amp;q.<span class="built_in">empty</span>()) sum+=c[id],ans[id]=time,mk.<span class="built_in">push</span>(&#123;<span class="number">1</span>,time+b[id],id&#125;);</span><br><span class="line">        <span class="keyword">else</span> q.<span class="built_in">push</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> 题解 </tag>
            
            <tag> 信息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近期计划</title>
      <link href="/2025/09/14/%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%92/"/>
      <url>/2025/09/14/%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h3 id="关于近期的规划"><a href="#关于近期的规划" class="headerlink" title="关于近期的规划"></a>关于近期的规划</h3><p>昨天其实我写了一篇文章，回忆了很久，还是没发出来，那是撤稿的第二篇了。<br>我的语言还是跟内心一般繁杂，所以那篇文章才写了很久，这点我之后会慢慢改的。</p><p>接下来，我会：</p><ul><li>减少游戏时长<br>手机游戏已经卸载 2025&#x2F;9&#x2F;13</li><li>减少短视频时长<br>我现在主用B站，但还是有用的不能卸载，把B站和抖音收在文件夹里让我不能直接在桌面打开，看微信也很容易刷起来朋友圈、视频号，目前把微信也收起来了 2025&#x2F;9&#x2F;13</li><li>规律作息<br>十点半前睡觉，六点半左右起床，假期变更半个小时。</li><li>运动<br>不宅了，去跑会步打会球</li><li>学习<br>先把信息好好学，考完CSP再把重心转到数学和校内。2025&#x2F;9&#x2F;14</li><li>娱乐<br>不看那些短视频了，把娱乐时间统一一下，看看番和书。平时多听听音乐也好。2025&#x2F;9&#x2F;14</li></ul>]]></content>
      
      
      <categories>
          
          <category> 规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树链剖分</title>
      <link href="/2025/09/11/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
      <url>/2025/09/11/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>太好了孩子们，主播学了树链剖分<del>薄纱绿蓝紫题</del><br>2025&#x2F;9&#x2F;11 一个 911 的日子<br>前几天刚写了《雨》，没想到第二天便是阳光明媚，甚至是暴晒，我们初三去跑操还在阳光最大的地方暴晒了 1 小时，给我大帅哥晒成包青天，白月光晒成黑魔仙了。<br>于是，有了<br>$$\ce{6CO2 + 6H2O -&gt;[{\text{光}}][{\text{叶绿体}}] C6H12O6 + 6O2}$$<br>把光能转化成学习的动力了——总算不是打游戏。</p><h2 id="重链剖分"><a href="#重链剖分" class="headerlink" title="重链剖分"></a>重链剖分</h2><p>因为主播只会这个。</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>我们学过很多维护序列的数据结构，如 st 表、树状数组、线段树……<br>但树能用的好像没什么，那我们怎么把他们用到树上呢？（绝对不是我想线段树了，大笨蛋）<br>把树分成链就好了。但若是直接用 DFS 序来剖分链，链的数量可能会很大，最后又成了暴力了。<br>于是有了<strong>重链剖分</strong>。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>定义<strong>重孩子</strong>：子树最大的孩子。<br><strong>重链</strong>：除了第一个点其他都是重孩子的链。<br><strong>轻边</strong>：不属于任何重链的边，一定是轻孩子和父节点的边。<br>可以证明，重链和轻边的总数不会超过 $2\log n$<br>哇塞，可以把树变成 $O(\log n)$ 的链了！<br>我们直接两次 DFS，先求出 sz、fa、dep 和重孩子，再优先遍历重孩子，求出 dfn、top（链头，非重孩子的 top 是它本身）<br>然后再沿用倍增求 LCA 的思想即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sz[N],dep[N],wc[N],dfn[N],cnt,seq[N],top[N],fa[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> from)</span></span>&#123;</span><br><span class="line">    dep[u]=dep[from]<span class="number">+1</span>,sz[u]=<span class="number">1</span>,fa[u]=from;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==from) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">        <span class="keyword">if</span>(sz[v]&gt;sz[wc[u]]) wc[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> Top)</span></span>&#123;</span><br><span class="line">    dfn[u]=++cnt,seq[cnt]=u;</span><br><span class="line">    top[u]=Top;</span><br><span class="line">    <span class="keyword">if</span>(wc[u]!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(wc[u],Top);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:g[u])</span><br><span class="line">            <span class="keyword">if</span>(v!=fa[u]&amp;&amp;v!=wc[u]) <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//你想干什么都可以哦</span></span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="comment">//对dfn[top[x]]~dfn[x]序列操作</span></span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//min(dfn[x],dfn[y])~max(dfn[x],dfn[y])序列操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搭配线段树食用最佳！</p><h3 id="P3384-【模板】重链剖分-树链剖分"><a href="#P3384-【模板】重链剖分-树链剖分" class="headerlink" title="P3384 【模板】重链剖分&#x2F;树链剖分"></a>P3384 【模板】重链剖分&#x2F;树链剖分</h3><p><a href="https://www.luogu.com.cn/problem/P3384">蓝题模板</a><br>经典的树剖+线段树，后面的题基本都是。</p><details><summary>代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls o&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs o&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,m,r,p,a[N];</span><br><span class="line"><span class="type">int</span> sz[N],dep[N],wc[N],dfn[N],cnt,seq[N],top[N],fa[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> from)</span></span>&#123;</span><br><span class="line">    dep[u]=dep[from]<span class="number">+1</span>,sz[u]=<span class="number">1</span>,fa[u]=from;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==from) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">        <span class="keyword">if</span>(sz[v]&gt;sz[wc[u]]) wc[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> Top)</span></span>&#123;</span><br><span class="line">    dfn[u]=++cnt,seq[cnt]=u;</span><br><span class="line">    top[u]=Top;</span><br><span class="line">    <span class="keyword">if</span>(wc[u]!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(wc[u],Top);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:g[u])</span><br><span class="line">            <span class="keyword">if</span>(v!=fa[u]&amp;&amp;v!=wc[u]) <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum,add;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> o)</span></span>&#123;</span><br><span class="line">    tr[o].sum=(tr[ls].sum+tr[rs].sum)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tag</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> add)</span></span>&#123;</span><br><span class="line">    tr[o].add=(tr[o].add+add)%p;</span><br><span class="line">    tr[o].sum=(tr[o].sum+(r-l<span class="number">+1</span>)*add%p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//更新子节点</span></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">tag</span>(ls,l,mid,tr[o].add);</span><br><span class="line">    <span class="built_in">tag</span>(rs,mid<span class="number">+1</span>,r,tr[o].add);</span><br><span class="line">    tr[o].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[o].sum=a[seq[l]];<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(o);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        <span class="built_in">tag</span>(o,l,r,x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(o,l,r);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) <span class="built_in">update</span>(ls,l,mid,L,R,x);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) <span class="built_in">update</span>(rs,mid<span class="number">+1</span>,r,L,R,x);</span><br><span class="line">    <span class="built_in">pushup</span>(o); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[x]],dfn[x],z);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="built_in">min</span>(dfn[x],dfn[y]),<span class="built_in">max</span>(dfn[x],dfn[y]),z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) <span class="keyword">return</span> tr[o].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(o,l,r);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) res=(res+<span class="built_in">query</span>(ls,l,mid,L,R))%p;<span class="comment">//合并区间值</span></span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) res=(res+<span class="built_in">query</span>(rs,mid<span class="number">+1</span>,r,L,R))%p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qry</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        res=(res+<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[x]],dfn[x]))%p;</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res+<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="built_in">min</span>(dfn[x],dfn[y]),<span class="built_in">max</span>(dfn[x],dfn[y])))%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;r&gt;&gt;p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i],a[i]%=p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(r,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(r,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">int</span> op,x,y,z;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) cin&gt;&gt;x&gt;&gt;y&gt;&gt;z,<span class="built_in">upd</span>(x,y,z);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">2</span>) cin&gt;&gt;x&gt;&gt;y,cout&lt;&lt;<span class="built_in">qry</span>(x,y)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">3</span>) cin&gt;&gt;x&gt;&gt;z,<span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[x]+sz[x]<span class="number">-1</span>,z);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">4</span>) cin&gt;&gt;x,cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[x]+sz[x]<span class="number">-1</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="P3038-USACO11DEC-Grass-Planting-G"><a href="#P3038-USACO11DEC-Grass-Planting-G" class="headerlink" title="P3038 [USACO11DEC] Grass Planting G"></a>P3038 [USACO11DEC] Grass Planting G</h3><p><a href="https://www.luogu.com.cn/problem/P3384">边权转点权</a></p><details><summary>讲解</summary><p>令子节点的点权为与父亲连边的边权，然后 LCA 的点权不用算进去即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls o&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs o&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,m,r,a[N];</span><br><span class="line"><span class="type">int</span> sz[N],dep[N],wc[N],dfn[N],cnt,seq[N],top[N],fa[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> from)</span></span>&#123;</span><br><span class="line">    dep[u]=dep[from]<span class="number">+1</span>,sz[u]=<span class="number">1</span>,fa[u]=from;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==from) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">        <span class="keyword">if</span>(sz[v]&gt;sz[wc[u]]) wc[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> Top)</span></span>&#123;</span><br><span class="line">    dfn[u]=++cnt,seq[cnt]=u;</span><br><span class="line">    top[u]=Top;</span><br><span class="line">    <span class="keyword">if</span>(wc[u]!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(wc[u],Top);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:g[u])</span><br><span class="line">            <span class="keyword">if</span>(v!=fa[u]&amp;&amp;v!=wc[u]) <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum,add;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> o)</span></span>&#123;</span><br><span class="line">    tr[o].sum=tr[ls].sum+tr[rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tag</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> add)</span></span>&#123;</span><br><span class="line">    tr[o].add+=add;</span><br><span class="line">    tr[o].sum+=(r-l<span class="number">+1</span>)*add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//更新子节点</span></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">tag</span>(ls,l,mid,tr[o].add);</span><br><span class="line">    <span class="built_in">tag</span>(rs,mid<span class="number">+1</span>,r,tr[o].add);</span><br><span class="line">    tr[o].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[o].sum=a[seq[l]];<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(o);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        <span class="built_in">tag</span>(o,l,r,x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(o,l,r);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) <span class="built_in">update</span>(ls,l,mid,L,R,x);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) <span class="built_in">update</span>(rs,mid<span class="number">+1</span>,r,L,R,x);</span><br><span class="line">    <span class="built_in">pushup</span>(o); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[x]],dfn[x],z);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x!=y) <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="built_in">min</span>(dfn[x],dfn[y])<span class="number">+1</span>,<span class="built_in">max</span>(dfn[x],dfn[y]),z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) <span class="keyword">return</span> tr[o].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(o,l,r);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) res+=<span class="built_in">query</span>(ls,l,mid,L,R);<span class="comment">//合并区间值</span></span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) res+=<span class="built_in">query</span>(rs,mid<span class="number">+1</span>,r,L,R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qry</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        res+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[x]],dfn[x]);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res+<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="built_in">min</span>(dfn[x],dfn[y])<span class="number">+1</span>,<span class="built_in">max</span>(dfn[x],dfn[y]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;P&#x27;</span>) <span class="built_in">upd</span>(u,v,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="built_in">qry</span>(u,v)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="P4092-HEOI2016-TJOI2016-树-P4116-Qtree3"><a href="#P4092-HEOI2016-TJOI2016-树-P4116-Qtree3" class="headerlink" title="P4092 [HEOI2016&#x2F;TJOI2016] 树 &amp;&amp; P4116 Qtree3"></a>P4092 [HEOI2016&#x2F;TJOI2016] 树 &amp;&amp; P4116 Qtree3</h3><p><a href="https://www.luogu.com.cn/problem/P4092">简单1</a><br><a href="https://www.luogu.com.cn/problem/P4116">简单2</a></p><details><summary>讲解</summary><p>两道题类似，都可以直接用线段树维护，但两者都有更简单的写法——前者并查集，后者 set。</p><h4 id="线段树写法（题1的，题2基本双倍经验）"><a href="#线段树写法（题1的，题2基本双倍经验）" class="headerlink" title="线段树写法（题1的，题2基本双倍经验）"></a>线段树写法（题1的，题2基本双倍经验）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls o&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs o&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,m,r,p,a[N];</span><br><span class="line"><span class="type">int</span> sz[N],dep[N],wc[N],dfn[N],cnt,seq[N],top[N],fa[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> from)</span></span>&#123;</span><br><span class="line">    dep[u]=dep[from]<span class="number">+1</span>,sz[u]=<span class="number">1</span>,fa[u]=from;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==from) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">        <span class="keyword">if</span>(sz[v]&gt;sz[wc[u]]) wc[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> Top)</span></span>&#123;</span><br><span class="line">    dfn[u]=++cnt,seq[cnt]=u;</span><br><span class="line">    top[u]=Top;</span><br><span class="line">    <span class="keyword">if</span>(wc[u]!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(wc[u],Top);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:g[u])</span><br><span class="line">            <span class="keyword">if</span>(v!=fa[u]&amp;&amp;v!=wc[u]) <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> o)</span></span>&#123;</span><br><span class="line">    tr[o]=<span class="built_in">max</span>(tr[ls],tr[rs]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tag</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=pos&amp;&amp;pos&lt;=r) tr[o]=<span class="built_in">max</span>(tr[o],pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[o]=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(o);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[o]=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">update</span>(ls,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs,mid<span class="number">+1</span>,r,x);</span><br><span class="line">    <span class="built_in">pushup</span>(o); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) <span class="keyword">return</span> tr[o];</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(ls,l,mid,L,R));<span class="comment">//合并区间值</span></span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(rs,mid<span class="number">+1</span>,r,L,R));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qry</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[x]],dfn[x]));</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seq[<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="built_in">min</span>(dfn[x],dfn[y]),<span class="built_in">max</span>(dfn[x],dfn[y])))];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;Q&#x27;</span>) cout&lt;&lt;<span class="built_in">qry</span>(x,<span class="number">1</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="P3976-TJOI2015-旅游"><a href="#P3976-TJOI2015-旅游" class="headerlink" title="P3976 [TJOI2015] 旅游"></a>P3976 [TJOI2015] 旅游</h3><p><a href="https://www.luogu.com.cn/problem/P3976">紫题</a><br>其实没有比前面蓝题难多少。线段树维护一下前-后和后-前的最大值，在模板基础上判断一下链的方向即可。<br>注意我用的重载运算符，加法要注意顺序（写 merge 函数可能会好分辨一点）</p><details><summary>代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls o&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs o&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>,inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"><span class="type">int</span> sz[N],dep[N],wc[N],dfn[N],cnt,seq[N],top[N],fa[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> from)</span></span>&#123;</span><br><span class="line">    dep[u]=dep[from]<span class="number">+1</span>,sz[u]=<span class="number">1</span>,fa[u]=from;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==from) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">        <span class="keyword">if</span>(sz[v]&gt;sz[wc[u]]) wc[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> Top)</span></span>&#123;</span><br><span class="line">    dfn[u]=++cnt,seq[cnt]=u;</span><br><span class="line">    top[u]=Top;</span><br><span class="line">    <span class="keyword">if</span>(wc[u]!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(wc[u],Top);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:g[u])</span><br><span class="line">            <span class="keyword">if</span>(v!=fa[u]&amp;&amp;v!=wc[u]) <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> qh,hq,mx,mn,add;</span><br><span class="line">    node <span class="keyword">operator</span> +(<span class="type">const</span> node&amp;w)<span class="type">const</span>&#123;<span class="comment">//注意这里加法有顺序！ </span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="built_in">max</span>(&#123;qh,w.qh,mx-w.mn&#125;),<span class="built_in">max</span>(&#123;hq,w.hq,w.mx-mn&#125;),<span class="built_in">max</span>(mx,w.mx),<span class="built_in">min</span>(mn,w.mn),<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> o)</span></span>&#123;</span><br><span class="line">    tr[o]=tr[ls]+tr[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tag</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> add)</span></span>&#123;</span><br><span class="line">    tr[o].add+=add,tr[o].mx+=add,tr[o].mn+=add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//更新子节点</span></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">tag</span>(ls,l,mid,tr[o].add);</span><br><span class="line">    <span class="built_in">tag</span>(rs,mid<span class="number">+1</span>,r,tr[o].add);</span><br><span class="line">    tr[o].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[o]=&#123;<span class="number">0</span>,<span class="number">0</span>,a[seq[l]],a[seq[l]],<span class="number">0</span>&#125;;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(o);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        <span class="built_in">tag</span>(o,l,r,x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(o,l,r);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) <span class="built_in">update</span>(ls,l,mid,L,R,x);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) <span class="built_in">update</span>(rs,mid<span class="number">+1</span>,r,L,R,x);</span><br><span class="line">    <span class="built_in">pushup</span>(o); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) <span class="keyword">return</span> tr[o];</span><br><span class="line">    <span class="built_in">pushdown</span>(o,l,r);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    node res=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,inf,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) res=res+<span class="built_in">query</span>(ls,l,mid,L,R);<span class="comment">//合并区间值</span></span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) res=res+<span class="built_in">query</span>(rs,mid<span class="number">+1</span>,r,L,R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[x]],dfn[x],z); </span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[y],z); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qry</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    node l,r;<span class="comment">//u和v的 </span></span><br><span class="line">    l=r=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,inf,<span class="number">0</span>&#125;; </span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])&#123;</span><br><span class="line">            r=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[y]],dfn[y])+r;</span><br><span class="line">            y=fa[top[y]]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[x]],dfn[x])+l;</span><br><span class="line">            x=fa[top[x]]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) l=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[y],dfn[x])+l;</span><br><span class="line">    <span class="keyword">else</span> r=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[y])+r;</span><br><span class="line">    <span class="built_in">swap</span>(l.qh,l.hq);</span><br><span class="line">    <span class="keyword">return</span> (l+r).hq; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,z; </span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">qry</span>(x,y)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">upd</span>(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 总结 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息 </tag>
            
            <tag> 模板 </tag>
            
            <tag> 总结 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雨</title>
      <link href="/2025/09/08/%E9%9B%A8/"/>
      <url>/2025/09/08/%E9%9B%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>2025&#x2F;9&#x2F;8，受台风“塔巴”影响，深圳发布台风黄色预警，全市中小学幼儿园听课。故有此篇。</p><hr><p>&emsp;&emsp;我很喜欢雨天。<br>&emsp;&emsp;对于小雨的解释很简单，“润物细无声”，舒适、凉爽。但暴雨呢？<br>&emsp;&emsp;一开始，我的想法很简单。我小时候看了今日说法，里面有一个人躲在床底下然后出来偷袭别人，给那时候的我留下了很大的阴影，于是每次睡觉都提心吊胆。由于年龄慢慢变大了，我也不能一直让母亲陪着我睡，我便开始期盼下雨的时候下雨——似乎认为没有人能在雨夜偷袭别人了（现在想起来似乎更恐怖）。那时候每个雨夜，我都睡得很香。<br>&emsp;&emsp;后来，我不怕了，但还是很喜欢睡觉的时候下雨，那雨滴的声音绝对是最好的助眠主播。渐渐的，发现很多跟我一样喜欢睡觉的时候下雨，这也就不足为奇了。<br>&emsp;&emsp;然而，我不只喜欢睡觉的时候下雨。只要我在室内，我都不会拒绝雨的到来，甚至越大越好。我对这种莫名的感情感到疑惑，却迟迟没有找到原因。起初，我认为是下大雨代表着有希望听课，但我发现自己似乎并不是那么讨厌去学校，并且即使在学校明知道就算下红暴也不能回家，也很期盼雨。放假的时候亦是如此。这个理由就被充分的排除了。<br>&emsp;&emsp;由于是在深圳，台风暴雨对于我们来说是常事，上学期间常常会遇到大暴雨。每次在校内遇到大雨，我都会在课间走出教室，或是走到走廊伸手触摸，或是走到1楼看看水面，甚至还会到顶楼去感受。最后一个我基本只在七下干过了。用现在的网络热梗来说，这就是你们眼中的嘉豪——我不否认，我以前确实很爱哗众取宠。但哪些东西是为了迎合，哪些东西是发自真心的，我于近几个月渐渐明白了。<br>&emsp;&emsp;七下的一次大暴雨，不过是在周末。母亲住院，父亲去照看奶奶，我一个人在家，便把朋友叫来家里。玩到夜深，窗外雨仍然倾盆而下，我问他怎么回家，他也不知道。我心中便萌生了一个想法：在我家过夜吧。初中还没有别人来我家过夜，恰逢父母不在（外加我的心烦意乱），不如就来一次吧！换做平时，我可能还会理智一点，考虑到我家里乱、他没带衣服什么的，但在雨声中我似乎听不见其他所谓秩序、外人的干扰，只能听见自己的纯粹的心声。他就在我家睡下了。<br>&emsp;&emsp;两个青春少年一起过夜，怎么可能睡得着呢？果然是彻夜无眠。在这个“世界末日”，我们玩了MC，自己煮了泡面，帮他找了洗浴用品……我们聊天，从游戏动漫到感情过往再到天下大事都是常见的，甚至干了一些现在想来有些不可思议的事。后来，我们在黑暗中模仿影院，看了《你的名字》和《天气之子》。<br>&emsp;&emsp;<em>“雨天，正适合重温老电影。”</em><br>&emsp;&emsp;这是孙尚香时之恋人皮肤的台词。环境很符合，我就看了这些老电影。我有了一些很特殊的感觉，至今我还有很多不能描述出来。这两部我第一次看，是在小升初的暑假陪三个兄弟，也是在过夜的时候看的，那时候似乎也没啥太大的感触，只是觉得有些美。但这次看了，感触很深，说不出来的感觉，但主角的名字、经典的台词、BGM都深深刻在了我的脑海里。<br>&emsp;&emsp;我现在能描述的，就是看了《天气之子》之后，对我喜欢雨的原因有了新的解释。<br>&emsp;&emsp; <strong>“我们喜欢的不是暴风雨，而是暴风雨为我们撕开的现实秩序的裂缝，在缝中透露出的虚幻的、浪漫的理想。”</strong> 是的，帆高离家出走，逃避了自己规规矩矩的命运，在被雨覆盖的东京流浪。偶然遇到了阳菜，她帮了他，于是后来他帮了她，在与风俗店老板的政治过程中开了自己偶然捡来的枪，幸亏没打中，逃到废弃大楼丢弃了。在雨中，帆高一次次偶然打破了常规的“秩序”，再知道阳菜是晴女后，和她一起实现东京人民的放晴愿望。但代价是，过度使用会消失、并且如果停止天气会更恶劣。多的我就不赘述了，总之新海诚画的很美，客厅电视4K+黑暗氛围下很震撼，如果在电影院内应该会更震撼人心（期待重映）。<br>&emsp;&emsp;如果不是暴雨打破了生活的秩序，或许帆高根本不会有这样的经历。阳菜是晴女，因此天气才会折射她的内心。然后，对于我和帆高来说，则是天气在影响我们了。暴雨的世界，学校停课、街道混乱，很多人无心管理，严格的秩序也变得疏松，我们才有机会在这井然有序的生活中喘了口气，趁秩序的裂缝去经历不同于以往的感受。并不是说我讨厌平常的秩序，只是过的多了总会厌倦，并且这种秩序未必是我完全认可的。就举个例子，在校内，下暴雨，原本安静的自习课会难的添上几分被允许的声音，我们不在只专注于桌上的几行字，而是抬起头往向窗外——风雨交加也好，电闪雷鸣也罢，但我们总是能看到其他人、看到一些我们平常没注意到的。固然，有的景很美，但美的意义也是我们去赋予的。在这种“世界末日”的氛围下，我们这一亩三分地倒显得像末日中的诺亚方舟，我们会更加珍惜身边的事物、身边的人。我的意思是，暴风雨撕开的现实的裂缝，能让我们看到更多被忽略的东西。<br>&emsp;&emsp;还有很多原因是我没有提到的。雨本身就是个意象，在文化中被赋予了各种各样的含义。<br>&emsp;&emsp;“随风潜入夜，润物细无声。” 这是希望；<br>&emsp;&emsp;“寒雨连江夜入吴，平明送客楚山孤。” 这是悲愁；<br>&emsp;&emsp;“沾衣欲湿杏花雨，吹面不寒杨柳风。” 这是朦胧；<br>&emsp;&emsp;“莫听穿林打叶声，何妨吟啸且徐行。” 这是人生。<br>&emsp;&emsp;这是再加上过往我们在雨天的回忆，每个人都会有自己独特的感受。对于雨的情感，也就会因人而异了。但我也总算搞明白了，我喜欢雨的原因。</p><p><em><strong>即使再也没有晴天也没关系！<br>比起蓝天，我更需要阳菜你！<br>天气什么的，就这么错乱下去也无所谓！</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初三第一周</title>
      <link href="/2025/09/06/%E5%88%9D%E4%B8%89%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
      <url>/2025/09/06/%E5%88%9D%E4%B8%89%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
      
        <content type="html"><![CDATA[<p>以前放学，听着音乐 像伤感深情的片尾曲 有飞鸟和夕阳<br>​现在放学，走在路上 像群贤毕至的开头曲 你的身边会经过这些人:放肆的初三，细腻的初二，更有百态的初一<br>​真的愈发感觉自己老了，这一届初一给我的感觉太奇特了……<br><img src="https://tc-new.z.wiki/autoupload/f/EWB9z1VeWPAhbCMNJEaASdiO_OyvX7mIgxFBfDMDErs/20250906/rJTY/2276X950/view1.webp/webp" alt="学校景色"></p>]]></content>
      
      
      <categories>
          
          <category> 杂事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂事 </tag>
            
            <tag> 伤感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串综合</title>
      <link href="/2025/09/06/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%BC%E5%90%88/"/>
      <url>/2025/09/06/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%BC%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串综合"><a href="#字符串综合" class="headerlink" title="字符串综合"></a>字符串综合</h1><p>字符串，一个我小时候学 python 就爱之入骨的数据类型<br>他的拼接什么的真的太方便啦！</p><h2 id="字符串的相关定义"><a href="#字符串的相关定义" class="headerlink" title="字符串的相关定义"></a>字符串的相关定义</h2><p>字符串，由若干字符组成的串。（以下知识可以类比集合）<br>记字符串为 $S$，其长度 $n$ 为 $|S|$<br><strong>子串</strong>：字符串 $S$ 的<strong>连续</strong>的一段子字符串。<br><strong>子序列</strong>：从字符串 $S$ 中提取若干个字符，保持原本的相对位置组成的序列，<strong>不要求连续</strong>。<br>前缀、后缀、回文串是常识。<br>字典序：类比字典，跟字典一样的排序方法。</p><h2 id="C-的字符串"><a href="#C-的字符串" class="headerlink" title="C++的字符串"></a>C++的字符串</h2><p>以前很爱用 char 数组，因为可以更简单实现下标从 $1$ 到 $n$<br>但现在发现 string 才是真神，快来用！！!<br>string 类型可以直接输入输出、比较，用 + 进行拼接，下标从 0 开始。<br> <figure class="highlight plaintext"><figcaption><span>``` 和 ``` s.length() ``` 可以 $O(1)$ 的返回字符串长度</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">字符串的比较是 $O(|S|)$ 的，慎用</span><br><span class="line">``` s1.find(s2) ``` 的复杂度是 $O(|S_1|·|S_2|)$</span><br><span class="line">那查找的效率太低了，所以有了 KMP</span><br><span class="line">## KMP</span><br><span class="line">*你我不合，未必无用*</span><br><span class="line">其中 b 数组表示 boader，即一个字符串里面最大的子串的长度，这个子串满足既是字符串的真前缀又是真后缀。我们能够 $O(|s|)$ 的求出 b 数组（这是最巧妙的地方），然后再用 b 数组 $O(|s_1|+|s_2|)$ 的查找。</span><br><span class="line">```cpp</span><br><span class="line">vector&lt;int&gt; prev(string s)&#123; </span><br><span class="line">    int n=s.length();</span><br><span class="line">    vector&lt;int&gt; b(n);</span><br><span class="line">    for(int i=1;i&lt;n;i++) &#123;</span><br><span class="line">        int j=b[i-1];</span><br><span class="line">        while(j&gt;0&amp;&amp;s[i]!=s[j]) j=b[j-1];</span><br><span class="line">        if(s[i]==s[j]) j++;</span><br><span class="line">        b[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125; </span><br><span class="line">vector&lt;int&gt; find(string s1,string s2)&#123;//返回的是出现的第一个字符的位置</span><br><span class="line">    string s=s2+&#x27;@&#x27;+s1;</span><br><span class="line">    int len1=s1.length(),len2=s2.length();</span><br><span class="line">    vector&lt;int&gt; res,b=prev(s); </span><br><span class="line">    for(int i=len2+1;i&lt;=len1+len2;i++)</span><br><span class="line">        if(b[i]==len2) res.push_back(i-2*len2);</span><br><span class="line">    return res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="字典树-Trie"><a href="#字典树-Trie" class="headerlink" title="字典树 Trie"></a>字典树 Trie</h2><p>已经是带“树”字的数据结构里面最短的了。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>处理字符串集合，支持</p><ul><li>插入</li><li>删除</li><li>查询</li><li>统计</li></ul><p>时间复杂度 $O(|s|)$<br>map（$O(|s|\log n)$）: 所以是不爱我了吗<br>答：Trie 还可以前缀统计，排序输出，求第 k 大</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getnum</span><span class="params">(<span class="type">char</span> x)</span></span>&#123;<span class="comment">//字符转数字</span></span><br><span class="line">    <span class="keyword">return</span> x-<span class="string">&#x27;a&#x27;</span>; </span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;x&lt;=<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> x-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;x&lt;=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> x-<span class="string">&#x27;a&#x27;</span><span class="number">+26</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x-<span class="string">&#x27;0&#x27;</span><span class="number">+52</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">    <span class="type">int</span> nxt[N][<span class="number">70</span>],tot,cnt[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">70</span>;j++) </span><br><span class="line">                nxt[i][j]=<span class="number">0</span>,cnt[i]=<span class="number">0</span>;</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">getnum</span>(c);</span><br><span class="line">            <span class="keyword">if</span>(nxt[pos][x]==<span class="number">0</span>) nxt[pos][x]=++tot;</span><br><span class="line">            pos=nxt[pos][x];</span><br><span class="line">            ++cnt[pos]; <span class="comment">//算前缀放这</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//只算字符串本身放这</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">getnum</span>(c);</span><br><span class="line">            pos=nxt[pos][x];</span><br><span class="line">            <span class="keyword">if</span>(--cnt[pos]==<span class="number">0</span>) nxt[pos][x]=<span class="number">0</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">getnum</span>(c);</span><br><span class="line">            <span class="keyword">if</span>(nxt[pos][x]) pos=nxt[pos][x];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt[pos]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;trie; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 总结 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生日快乐，公主殿下！</title>
      <link href="/2025/08/31/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%EF%BC%8C%E5%85%AC%E4%B8%BB%E6%AE%BF%E4%B8%8B%EF%BC%81/"/>
      <url>/2025/08/31/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%EF%BC%8C%E5%85%AC%E4%B8%BB%E6%AE%BF%E4%B8%8B%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>今天是初音生日，请大家看看我的 cos 视频吧！</p><video src="https://tc-new.z.wiki/autoupload/f/EWB9z1VeWPAhbCMNJEaASdiO_OyvX7mIgxFBfDMDErs/20250831/YKE1/fsct.mp4" autoplay="true" controls="controls" width="50%" height="50%"></video><p>公主殿下 18 周年啊，我竟然无所事事（恼<br>但初音对我的意义是不可否认的，她真的很好很好。<br><img src="https://tc-new.z.wiki/autoupload/f/EWB9z1VeWPAhbCMNJEaASdiO_OyvX7mIgxFBfDMDErs/20250906/Xlra/1080X1385/miku18b.webp/webp" alt="现状"><br>今天也是初三的第一天，结果考了一天的试，好惨哦（；´д｀）ゞ<br>本来想把班级的门关起来，强制每个同学看我的视频100遍再放学的。<br>生日快乐，公主殿下！有空我去补一补跟初音的故事。</p>]]></content>
      
      
      <categories>
          
          <category> 杂事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构一</title>
      <link href="/2025/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/"/>
      <url>/2025/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构一"><a href="#数据结构一" class="headerlink" title="数据结构一"></a>数据结构一</h1><p>本分类仅供复习、整理模板使用，不适用于第一次学。<br>与树有关的数据结构：</p><ul><li>并查集</li><li>ST表</li><li>树状数组 </li><li>线段树</li></ul><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><em><strong>并查集能 O(1) 的找到点的集合，我遍历所有却仍旧没有找到归属</strong></em><br>不得不说与其他数据结构相比，并查集真的是高效又好看，她甚至还是我的白月光……（指第一个学的数据结构）</p><h3 id="用途及要求"><a href="#用途及要求" class="headerlink" title="用途及要求"></a>用途及要求</h3><p>判断连通性（所属集合），支持合并和查询。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>$fa_x$ 表示 $x$ 节点的父亲，可以构建出一个森林。同根的两点在同一集合内。若 $x$ 是根则 $fa_x&#x3D;x$<br>合并 $x,y$：令 $x$ 的根是 $y$ 的根的父亲。<br>查询：递归 $fa_x$ 至 $fa_x&#x3D;x$，即寻找所在的树的根。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>路径压缩最坏 $O(\log n)$，路径压缩+启发式合并接近 $O(1)$。一般只使用路径压缩即可。初始化 $fa_x&#x3D;x, sz_x&#x3D;1$</p><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y) fa[x]=y;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="路径压缩-启发式合并"><a href="#路径压缩-启发式合并" class="headerlink" title="路径压缩+启发式合并"></a>路径压缩+启发式合并</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(sz[x]&gt;sz[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    fa[x]=y,sz[y]+=sz[x];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><p><em><strong>即使是倍增的去接近你，我也需要你能忍受我的反复才能相遇<br>否则无论思念如何重复，我也找不回你的答案</strong></em></p><h3 id="用途及要求-1"><a href="#用途及要求-1" class="headerlink" title="用途及要求"></a>用途及要求</h3><p>查询任意区间 $[L,R]$的值，需要满足<strong>可重复计算贡献</strong><br>即 $x&#x3D;cal(x,x)$，如 max, min, 按位与, 按位或, lca……</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>倍增思想，类似 LCA 中求 $fa$<br>$st_{i,j}$ 表示左端点为 $i$，长度为 $2^j$ 的区间的值。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>预处理后不可修改。预处理 $O(n\log n)$，查询 $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) st[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;len)&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+(<span class="number">1</span>&lt;&lt;len)<span class="number">-1</span>&lt;=n;l++)</span><br><span class="line">            st[l][len]=<span class="built_in">max</span>(st[l][len<span class="number">-1</span>],st[l+(<span class="number">1</span>&lt;&lt;len<span class="number">-1</span>)][len<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="built_in">log</span>(r-l<span class="number">+1</span>)/<span class="built_in">log</span>(<span class="number">2.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)<span class="number">+1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p><em><strong>有了线段树，你还会爱我吗?<br>会的。我们只是正常朋友关系。<br>可她比我全能，要求比我少，心思比我更好想！<br>不要再多虑了，你的常数和码量都是她无法比拟的。<br>还有，你是我心中那个只会单点修改的小傻瓜啊</strong></em></p><h3 id="用途及要求-2"><a href="#用途及要求-2" class="headerlink" title="用途及要求"></a>用途及要求</h3><p>基础：单点修改+区间查询<br>扩展：区间修改+查询<br>树状数组维护的信息及运算要满足<strong>结合律</strong>且<strong>可差分</strong>的。（OI-wiki）<br>如区间和、区间乘、区间异或。</p><h3 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>原理类似线段树，对半分为很多个小区间，但发现有的区间是可以通过大减小等方式又由其他区间计算而得，可以删去。剩下的区间找规律，发现：$tr_i$ 表示以 $i$ 为右边界，长度为 <code>lowbit(i)=i&amp;-i</code> 的区间和。这样可以计算出任何 $[1,i]$ 的值。</p><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>原版支持单点修改+区间查询，复杂度均为 $O(\log n)$<br>搭配差分即可实现区间修改+单点查询。<br>实现比线段树简单，常数比线段树小，原理比线段树复杂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;tr[i]+=x;i+=i&amp;-i;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i)&#123;res+=tr[i];i-=i&amp;-i;&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h4><p>这时候就有聪明的小朋友要问了：那我要是想既能区间修改，又能区间查询呢？<br><del>直接线段树</del><br>查询总比修改简单，所以我们在差分后能区间修改的树状数组基础上改，考虑区间查询。<br>设原数组 $a$，差分数组 $d$，区间和 $sum$，则有：<br>$$a_i&#x3D;\sum_{j&#x3D;1}^id_j$$<br>$$sum_k&#x3D;\sum_{i&#x3D;1}^ka_i&#x3D;\sum_{i&#x3D;1}^k\sum_{j&#x3D;1}^id_j$$</p><h5 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h5><p>$$\sum_{i&#x3D;1}^k\sum_{j&#x3D;1}^id_j&#x3D;\sum_{j&#x3D;1}^k\sum_{i&#x3D;j}^kd_j&#x3D;\sum_{j&#x3D;1}^kd_j\times(k-j+1)$$</p><h5 id="解法2："><a href="#解法2：" class="headerlink" title="解法2："></a>解法2：</h5><p>$a_1&#x3D;d_1$<br>$a_2&#x3D;d_1+d_2$<br>$a_3&#x3D;d_1+d_2+d_3$<br>$\dots$<br>$a_k&#x3D;d_1+d_2+d_3+\dots+d_k$<br>不难发现，对 $a$ 求和的话（即竖着加），$d_j$ 出现了 $k-j+1$ 次，结果同解法1。<br>$$sum_k&#x3D;\sum_{j&#x3D;1}^kd_j\times(k-j+1)&#x3D;(k+1)\sum_{j&#x3D;1}^kd_j-\sum_{j&#x3D;1}^kd_j\times j$$<br>其中 $k$ 是定值，我们发现令 $b_j&#x3D;d_j\times j$ 的话，两个求和都可以分别用 $d$ 和 $b$ 的树状数组查询，那么 $sum$ 就可求了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=i; </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        tr1[i]+=x,tr2[i]+=x*k; </span><br><span class="line">        i+=i&amp;-i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(l,x);<span class="built_in">add</span>(r<span class="number">+1</span>,-x);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,k=i;</span><br><span class="line">    <span class="keyword">while</span>(i)&#123;</span><br><span class="line">        res+=(k<span class="number">+1</span>)*tr1[i]-tr2[i];</span><br><span class="line">        i-=i&amp;-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(r)-<span class="built_in">query</span>(l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（函数名重复？引用名言：<em>参数不一样~</em> ）</p><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p><em><strong>树状数组，你听我解释！！！<br>即使是万能的线段树，也无法维护你我之间的关系。因为，我们的联系不容得懒惰的标记。</strong></em></p><h3 id="用途及要求-3"><a href="#用途及要求-3" class="headerlink" title="用途及要求"></a>用途及要求</h3><p>请输入文本<br>基本啥区间信息都能维护，就是难写。能区间修改，区间查询。</p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>建树 $O(n)$，查询和修改 $O(\log n)$，常数出了名的大，容易被卡。<br>卡常：喜欢无脑写线段树的小朋友你们好啊，我是卡常，老老实实给我写树状数组或其他方法去吧。</p><h3 id="普通线段树-懒惰标记"><a href="#普通线段树-懒惰标记" class="headerlink" title="普通线段树+懒惰标记"></a>普通线段树+懒惰标记</h3><p>基本只用修改 tag 函数，其他地方很容易改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls o&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs o&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> val,lzy;<span class="comment">//维护的值和懒惰标记</span></span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> o)</span></span>&#123;</span><br><span class="line">    <span class="comment">//更新父节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tag</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="comment">/*标记*/</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//打标记+更新值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//更新子节点</span></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">tag</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">tag</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="comment">//重置标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[o].sum=a[l];<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(o);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        <span class="built_in">tag</span>(o,l,r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(o,l,r);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) <span class="built_in">update</span>(ls,l,mid,L,R);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) <span class="built_in">update</span>(rs,mid<span class="number">+1</span>,r,L,R);</span><br><span class="line">    <span class="built_in">pushup</span>(o); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) <span class="keyword">return</span> tr[o].val;</span><br><span class="line">    <span class="built_in">pushdown</span>(o,l,r);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) res+=<span class="built_in">query</span>(ls,l,mid,L,R);<span class="comment">//合并区间值</span></span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) res+=<span class="built_in">query</span>(rs,mid<span class="number">+1</span>,r,L,R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态开点"><a href="#动态开点" class="headerlink" title="动态开点"></a>动态开点</h3>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 总结 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP综合</title>
      <link href="/2025/08/27/DP%E7%BB%BC%E5%90%88/"/>
      <url>/2025/08/27/DP%E7%BB%BC%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="DP综合"><a href="#DP综合" class="headerlink" title="DP综合"></a>DP综合</h1><p>DP（Dynamic Programming），又称动态规划，<del>就是动态地进行规划</del>。<br>正式定义：通过把复杂问题分解为简单的<strong>子问题</strong>来求解的方法，并不是指某种具体的算法。用来解决的问题具有 <strong>最优子结构，无后效性，重叠子问题</strong> 这三种特性。<br>个人理解：高级的递推，用已知解去更新未知解。也是区分蒟蒻和巨佬的重要手段。同时用途极广，和数学中的数列一样，可以结合其他知识点出很难的题。<br>关键步骤：</p><ul><li>设计<strong>状态</strong>（将原问题分解为子问题）</li><li>推导<strong>状态转移方程</strong></li><li>按顺序实现<strong>状态转移</strong></li></ul><p>状态转移实现：递推（循环）   递归（<strong>记忆化搜索</strong>）<br>接下来介绍几种常见的模型。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>线性 DP<ul><li>背包 DP</li><li>区间 DP</li><li>LCA</li></ul></li><li>树形 DP<ul><li>普通树形</li><li>换根 DP</li></ul></li><li>状压 DP</li><li>数位 DP</li></ul><h2 id="线性-DP"><a href="#线性-DP" class="headerlink" title="线性 DP"></a>线性 DP</h2><p>最基础的一类 DP，线性的进行状态转移。</p><h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><p>经典 DP 模型。</p><h4 id="引入（01背包）"><a href="#引入（01背包）" class="headerlink" title="引入（01背包）"></a>引入（01背包）</h4><p>$N$ 个物品，第 $i$ 个物品的重量 $w_i$，价值 $v_i$，以及背包总容量 $W$，最大化能取的物品的价值。<br>定义 $dp_{i,j}$ 为前 $i$ 个物品，占用了 $j$ 的容量的最大价值。转移方程：<br>$$dp_{i,j}&#x3D;max{dp_{i-1,j-w_i}+v_i}$$</p><h4 id="滚动数组空间优化"><a href="#滚动数组空间优化" class="headerlink" title="滚动数组空间优化"></a>滚动数组空间优化</h4><p>注意到 dp 数组的空间复杂度为 $O(NW)$，很大。又发现每次 $dp_i$ 只用 $dp_{i-1}$ 转移，可以直接把这一维度优化掉，但循环顺序要改变。</p><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举物品 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=W;j&gt;=w[i];j--)<span class="comment">//枚举体积</span></span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举物品 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=w[i];j&lt;=W;j++)<span class="comment">//枚举体积</span></span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure><h2 id="树形DP-简介"><a href="#树形DP-简介" class="headerlink" title="树形DP 简介"></a>树形DP 简介</h2><p>顾名思义，就是在树上进行 DP。由于树的递归性质，通常的写法就是在 dfs 遍历树时进行状态转移。<br><br>通常，$dp_u$ 状态一般都为以 $u$ 为根的子树的最优解。先 dfs 遍历子树的所有最优解，然后向上传递给子树的父节点来转移，最终根节点的值即为所求的最优解（当然也有向下转移的）。</p><h2 id="换根DP"><a href="#换根DP" class="headerlink" title="换根DP"></a>换根DP</h2><p>上述的普通树形 DP 只能求解一个固定点为根，若是要枚举每一个根，岂不是得 $O(n^2)$ ？<br>非也非也，我们发现相邻的节点作为根，树除了他们俩本身基本不会有啥变化，因此换根的时候只有修改他俩的 DP 值就好了，复杂度 $O(n)$。就会有以下神板，只需推出一个转移式即可：</p><h3 id="模板1"><a href="#模板1" class="headerlink" title="模板1"></a>模板1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])</span><br><span class="line">        <span class="keyword">if</span>(v!=pre) <span class="built_in">dfs1</span>(v,u),<span class="comment">/*v对u转移;*/</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uv</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">//v对u还原 </span></span><br><span class="line">    <span class="comment">//u对v转移 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>&#123;</span><br><span class="line">    <span class="comment">//此时dp[u]的值就是u作为根 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])</span><br><span class="line">        <span class="keyword">if</span>(v!=pre) <span class="built_in">uv</span>(u,v),<span class="built_in">dfs2</span>(v,u),<span class="built_in">uv</span>(v,u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 总结 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 模板 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC419E题解</title>
      <link href="/2025/08/26/ABC419E%E9%A2%98%E8%A7%A3/"/>
      <url>/2025/08/26/ABC419E%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>有点耻辱，打比赛的时候去吃饭了，最后赛后 20 分钟就把 E 题写出来了……还给我掉了分╥﹏╥…<del>又被 ABC 做局了。</del></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>  给定长为 $N$ 的整数序列，每次操作可以将单个元素加一，求至少多少次操作，使得每个长为 $L$ 的子段和为 $M$ 的倍数。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>让每个固定长度的子段和为一个数的倍数……这一眼就很数学，或者说很有规律啊。我们发现，如果有<br>$$\sum_{i&#x3D;k}^{k+L-1}a_i\equiv \sum_{i&#x3D;k+1}^{k+L}a_i\equiv0\pmod{M}$$<br>那恒等式两边减去公共部分 $\sum_{i&#x3D;k+1}^{k+L-1}a_i$，就有<br>$$a_k\equiv a_{k+L}\pmod{M}$$<br>那我们就可以把每隔 $L$ 个的数分为一类，每类的数字对 $M$ 取模相同。那这样，我们只需要把前 $L$ 项的数算出，就可以用把剩下的都算出来了。</p><p>只用算前 $L$ 项，观察到 $L\leq N,M\leq500$，我们可以枚举每一项和前一项模 $M$ 的余数，就可使用动态规划进行状态转移（<del>一眼 dp</del>）。</p><p>令 $dp_{i,j}$ 表示使前 $i$ 项的和对 $M$ 取模为 $j$ 的最小操作数，$sum_{i,j}$ 表示把和 $i$ 同类的数对 $M$ 的余数都改为 $j$ 的最小操作数（ $sum$ 可以直接枚举算），那么转移式如下<br>$$ dp_{i, (j+k) mod \ M}&#x3D; \min (dp_{i-1,k}+sum_{i,j}) $$<br>其中 $k$ 表示前一项模 $M$ 的余数，$(j+k) mod \ M$ 表示这一项模 $M$ 的余数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>; </span><br><span class="line"><span class="type">int</span> n,m,l,a[N],ans,dp[N][N],sum; </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=l) </span><br><span class="line">            c[i].<span class="built_in">push_back</span>(a[j]); </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k:c[i]) sum+=(j-k+m)%m;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">                dp[i][(j+k)%m]=<span class="built_in">min</span>(dp[i][(j+k)%m],dp[i<span class="number">-1</span>][k]+sum);</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;dp[l][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> 题解 </tag>
            
            <tag> 同余 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC416E题解</title>
      <link href="/2025/08/26/ABC416E%E9%A2%98%E8%A7%A3/"/>
      <url>/2025/08/26/ABC416E%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>十年 OI 一场空，不开 long long 见祖宗。这是我第一次洛谷的官方题解。</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个 $N$ 个点，$M$ 条边的无向图，图中有 $K$ 个点有机场，有机场的点可以耗时 $T$ 时抵达另一个有机场的点。</p><p>有 $Q$ 个查询，分为 $3$ 种:加边、加机场、询问所有联通的点之间的最短距离之和。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>注意到 $N\leq500$，还要求最短路、加边，我们可以直接使用邻接矩阵存图，并用 Floyd 计算多源最短路。</p><p>使用 Floyd 进行加边操作很简单，假设加上了连接 $u,v$ 长度为 $w$ 的边，状态转移方程如下：</p><p>$$dis_{i,j}&#x3D;min{dis_{i,j},dis_{i,u}+w+dis_{v,j},dis_{i,v}+w+dis_{u,j}}$$</p><p>但是添加机场应该怎么处理呢？其实很简单（<del>虽然我在比赛的时候 D 没开 long long 调了好久导致E没时间</del>）。</p><p>可以<strong>添加一个虚点</strong> $N+1$，让这个点与所有有机场的点连接一条长为 $\frac{T}{2}$ 的边。有点新建机场时，只需让它与 $N+1$ 连边，即转化为加边操作，如上述方程转移即可。</p><p>为了避免浮点数一开始先将边权乘以 $2$，最后计算时再除以 $2$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>（上一题没开 long long 有阴影了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>;</span><br><span class="line"><span class="type">int</span> n,m,g[N][N],k,t;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">+1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n<span class="number">+1</span>;j++)</span><br><span class="line">            g[i][j]=<span class="built_in">min</span>(&#123;g[i][j],g[i][u]+w+g[v][j],g[i][v]+w+g[u][j]&#125;); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="type">int</span> inf=g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">+1</span>;i++) g[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        g[u][v]=g[v][u]=<span class="built_in">min</span>(g[u][v],w*<span class="number">2</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    cin&gt;&gt;k&gt;&gt;t;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;d),g[d][n<span class="number">+1</span>]=g[n<span class="number">+1</span>][d]=t; <span class="comment">//机场n+1 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">+1</span>;k++)<span class="comment">//floyd</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">+1</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n<span class="number">+1</span>;j++)</span><br><span class="line">                g[i][j]=<span class="built_in">min</span>(g[i][j],g[i][k]+g[k][j]);</span><br><span class="line">    <span class="type">int</span> q,op;</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> u,v,w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            <span class="built_in">add</span>(u,v,<span class="number">2</span>*w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">            <span class="built_in">add</span>(x,n<span class="number">+1</span>,t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                    <span class="keyword">if</span>(g[i][j]!=inf) tot+=g[i][j]/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,tot);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> 题解 </tag>
            
            <tag> 图论 </tag>
            
            <tag> Floyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环染色方案数</title>
      <link href="/2025/08/26/%E7%8E%AF%E6%9F%93%E8%89%B2%E6%96%B9%E6%A1%88%E6%95%B0/"/>
      <url>/2025/08/26/%E7%8E%AF%E6%9F%93%E8%89%B2%E6%96%B9%E6%A1%88%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个大小为 $n$ 的环，要求给环上每个节点染色为 $1 \sim k$ 中的某种颜色，使得任意两个相邻的节点颜色不同，询问染色的方案数。答案对 $10^9+7$ 取模。</p><h2 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h2><p>注意到 $n,k\leq10^9$，连数组都开不了，于是我们考虑数学（<del>还有数列大佬嘿嘿嘿</del>）。</p><p>定义 $A_n$ 表示染色方案数，如右图：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/o9aay657.png?x-oss-process=image/resize,m_lfit,h_170,w_225" alt="1"></p><ol><li>若 $1,n-1$ 不同色，方案数为 $(k-2)A_{n-1}$</li><li>若 $1,n-1$ 同色，方案数为 $(k-1)A_{n-2}$</li></ol><p>$$\therefore A_n&#x3D;(k-2)A_{n-1}+(k-1)A_{n-2}$$ </p><p>考虑到 $A_1&#x3D;k$ 不满足上式，令 $a_n&#x3D;A_{n+1},a_1&#x3D;k(k-1),a_2&#x3D;k(k-1)(k-2)$，也有：</p><p>$$a_n&#x3D;(k-2)a_{n-1}+(k-1)a_{n-2} \ ①$$ </p><p>熟悉的待定系数法，仿照斐波那契数列，设 $a_n+\mu a_{n-1}&#x3D;\lambda (a_{n-1}+\mu a_{n-2})\ ②$ </p><p>联立 $①②$，有  </p><p>$$\begin{cases} \lambda -\mu&#x3D;k-2 \newline \lambda\mu&#x3D;k-1<br>\end{cases}$$</p><p>很简单的方程，凑完全平方即可，取其中一个解</p><p>$$\begin{cases} \lambda&#x3D;k-1 \newline \mu&#x3D;1<br>\end{cases}$$</p><p>代入 $②$：$a_n+a_{n-1}&#x3D;(k-1)(a_{n-1}+a_{n-2})$</p><p>令 $b_n&#x3D;a_{n+1}+a_n$，则 $b_n&#x3D;(k-1)b_{n-1},b_1&#x3D;a_1+a_2&#x3D;k(k-1)^2$</p><p>$\therefore b$ 是以 $k(k-1)^2$ 为首项，$q&#x3D;(k-1)$ 的等比数列，$b_n&#x3D;b_1q^{n-1}&#x3D;k(k-1)^{n+1}$</p><p>$$\therefore a_{n+1}+a_n&#x3D;k(k-1)^{n+1} \ ③$$ </p><p>继续使用待定系数法，注意到 $n+1$ 出现在 $k$ 的指数上面，则对于 $a_n$ 也应该有个 $(k-1)^n$，即要多乘一个 $(k-1)$，于是设</p><p>$$a_{n+1}+m(k-1)&#x3D;-(a_n+m) \ ④$$ </p><p>联立 $③④$，解得 $m&#x3D;-(k-1)^{n+1}$</p><p>$$\therefore a_{n+1}-(k-1)^{n+2}&#x3D;-(a_n-(k-1)^{n+1})$$</p><p>令 $c_n&#x3D;a_n-(k-1)^{n+1}$，则 $c_n&#x3D;-c_{n-1},c_1&#x3D;a_1-(k-1)^2&#x3D;k-1$</p><p>$$\therefore c_n&#x3D;(k-1)\cdot(-1)^{n-1}$$</p><p>$$a_n&#x3D;(k-1)^{n+1}+(-1)^{n-1}\cdot(k-1)$$</p><p>$$A_n&#x3D;a_{n-1}&#x3D;(k-1)^n+(-1)^n(k-1)$$</p><p>收工！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>这本质上是个数学题，推出结论后就没什么难点了，唯一值得注意的地方是 $n\leq10^9$，直接暴力求幂肯定会超时，于是使用快速幂（<del>这就不用我讲了吧……</del>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>) r=r*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r%mod;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,k); </span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="built_in">pow</span>(k<span class="number">-1</span>,n)+((n&amp;<span class="number">1</span>)?(<span class="number">1</span>-k):(k<span class="number">-1</span>))+mod)%mod);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>我是不会告诉你我最后取模忘记先加上 $mod$，为此还调了半天的。</del></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC408E题解</title>
      <link href="/2025/08/26/ABC408E%E9%A2%98%E8%A7%A3/"/>
      <url>/2025/08/26/ABC408E%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>本题与这一道<a href="https://www.luogu.com.cn/problem/CF1624G">或最小生成树</a>思路一样，做完本题可以做这一道巩固一下。</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个连通无向图，求 $1$ 到 $n$ 的简单路径的边权之或的最小值。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>看到路径的最小值，首先想起最短路，用 dijkstra？但立即意识到不太行，并不是一个边权越大它与另个一个值按位或的值就会越大。</p><p>接下来以按位或的性质作为突破口。<strong>位运算中不同位是相对独立的</strong>，我们可以考虑从每一位枚举。</p><p><strong>如果答案的第 $i$ 位可以为 $0$，无论后面其它位是多少和都不会超过 $2^{i-1}$</strong>。 即若能取 $0$ 则永远比取 $1$ 优。所以我们从高位到低位贪心，尽量让高位不要取 $1$，如果可以取 $0$ 就取 $0$。</p><p>注意到数据范围 $0\leq w &lt;2^{30}$，枚举 $0\leq i \leq 30$。什么时候这一位必须要取 $1$ 呢？<strong>当只用这一位是 $0$，且前几位满足之前枚举的要求的边无法使 $1$ 与 $n$ 连通时，这一位就只能取 $1$ 了</strong>。</p><h3 id="举个例子-第一个样例："><a href="#举个例子-第一个样例：" class="headerlink" title="举个例子 第一个样例："></a>举个例子 第一个样例：</h3><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/sy0v69hz.png?x-oss-process=image/resize,m_lfit,h_200,w_400"></p><ul><li><p>当 $i&#x3D;2$ 时，我们去掉所有第 $3$ 位是 $1$ 的边，发现 $1$-&gt;$2$-&gt;$3$-&gt;$4$ 仍然可以到达，那我们就不取，$ans&#x3D;(000)_2$。</p></li><li><p>当 $i&#x3D;1$ 时，我们不仅不能取第 $2$ 位是 $1$的边，还要满足之前的条件，即第 $3$ 位是 $1$ 的不取。发现 $1$ 到不了 $4$ 了，于是这一位必须是 $1$，$ans&#x3D;(010)_2$。</p></li><li><p>当 $i&#x3D;0$ 时,和之前一样，但由于 $ans$ 第 $2$ 位已经取 $1$，我们可以取第 $2$ 位是 $1$的边。发现不连通，$ans&#x3D;(011)_2&#x3D;3$。</p></li></ul><h2 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h2><p>判断图联通可以用 bfs 等一系列方法，这里我采用并查集，并使用 $vis$ 数组判断该边可不可以使用。时间复杂度 $O((m+n)·\log(m))$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,m,fa[N],ans,num[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x==fa[x])?x:(fa[x]=<span class="built_in">find</span>(fa[x]));&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y) fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        e[i]=&#123;u,v,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">max</span>(n,m);i++) fa[i]=i,vis[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> cnt=n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(e[j].w&amp;(<span class="number">1</span>&lt;&lt;i))) <span class="built_in">merge</span>(e[j].u,e[j].v);<span class="comment">//这一位可以取</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(<span class="number">1</span>)==<span class="built_in">find</span>(n))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(e[j].w&amp;(<span class="number">1</span>&lt;&lt;i)) vis[j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ans+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) fa[j]=j;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> 题解 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC407E题解</title>
      <link href="/2025/08/26/ABC407E%E9%A2%98%E8%A7%A3/"/>
      <url>/2025/08/26/ABC407E%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>看到滑动窗口，很容易想到单调队列，但该做法在本题中时间复杂度达到了 $O(n^2)$，不可取，于是考虑计算每个元素在不同窗口的贡献。</p><p>首先，元素在哪些窗口会作为最大值？对于每一个 $i∈[1,n]$ 我们可以用<strong>单调栈</strong>预计算出左右两边第一个大于他的值，并得到其能向左&#x2F;右扩展多少步。同时为了避免重复计算贡献，我们使用左闭右开，即：</p><ul><li>向左找到最近的一个位置 $j$ 使得 $a_j\geq a_i$ （若不存在则为 $0$），则 $l_i&#x3D;i-j$</li><li>向右找到最近的一个位置 $j$ 使得 $a_j&gt;a_i$ （若不存在则为 $n+1$），则 $r_i&#x3D;j-i$</li></ul><hr><p>接下来分类讨论，计算贡献，记 $k$ 为滑动窗口的长度，$x&#x3D;min(l_i,r_i),y&#x3D;max(l_i,r_i)$，有：</p><ul><li>当 $k∈[1,x]$，对长度为 $k$ 的窗口有贡献的共有 $x$ 个，$ans_k&#x3D;ans_k+a_i k$</li><li>当 $k∈(x,y]$，对长度为 $k$ 的窗口有贡献的共有 $x$ 个，$ans_k&#x3D;ans_k+a_i x$</li><li>当$k∈(y,x+y)$，对长度为 $k$ 的窗口有贡献的共有 $(x+y-k)$ 个，$ans_k&#x3D;ans_k+(x+y-k) a_i$</li></ul><p>区间修改，单点查询，可以使用树状数组或者线段树，但最简单的还是差分。</p><p>维护 $p$，$q$ 差分数组，<strong>将上述操作含有 $k$ 的项归为 $p$，其余归为 $q$，答案 $ans_k&#x3D;\sum_{i&#x3D;1}^k p_i k+\sum_{i&#x3D;1}^k q_i$</strong></p><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],l[N],r[N];</span><br><span class="line"><span class="type">int</span> p[N],q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> *b,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;b[l]+=x,b[r<span class="number">+1</span>]-=x;&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;a[i]&gt;a[s.<span class="built_in">top</span>()]) s.<span class="built_in">pop</span>();</span><br><span class="line">        l[i]=i-(s.<span class="built_in">empty</span>()?<span class="number">0</span>:s.<span class="built_in">top</span>());</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) s.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;a[i]&gt;=a[s.<span class="built_in">top</span>()]) s.<span class="built_in">pop</span>();</span><br><span class="line">        r[i]=(s.<span class="built_in">empty</span>()?n<span class="number">+1</span>:s.<span class="built_in">top</span>())-i; </span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=l[i],y=r[i];</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y); </span><br><span class="line">        <span class="built_in">add</span>(p,<span class="number">1</span>,x,a[i]);</span><br><span class="line">        <span class="built_in">add</span>(q,x<span class="number">+1</span>,y,a[i]*x);</span><br><span class="line">        <span class="built_in">add</span>(p,y<span class="number">+1</span>,x+y,-a[i]);</span><br><span class="line">        <span class="built_in">add</span>(q,y<span class="number">+1</span>,x+y,a[i]*(x+y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        p[i]+=p[i<span class="number">-1</span>],q[i]+=q[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,p[i]*i+q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>蒟蒻第一次写题解，有格式不对请见谅，我会改进的QwQ。</p>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> 题解 </tag>
            
            <tag> 单调栈 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客「创世纪」</title>
      <link href="/2025/08/25/%E5%8D%9A%E5%AE%A2%E3%80%8C%E5%88%9B%E4%B8%96%E7%BA%AA%E3%80%8D/"/>
      <url>/2025/08/25/%E5%8D%9A%E5%AE%A2%E3%80%8C%E5%88%9B%E4%B8%96%E7%BA%AA%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="我的博客，终于启用了"><a href="#我的博客，终于启用了" class="headerlink" title="我的博客，终于启用了"></a>我的博客，终于启用了</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>经历了 4 天的调试，反反复复删了 2 次容器，花 15 块买了个域名 <a href="https://muyang.blog/">muyang.blog</a>，结果没钱升级所以服务不安全，暂时放弃了。能有现在的效果我已经很满意了。</p><p>我之后会持续在博客更新的，欢迎大家来观看！内容包括但不限于：</p><ul><li>数学&#x2F;信息知识分享</li><li>生活趣事（日记）</li><li>偶然灵感</li><li>看番、作品心得</li></ul><p>总之，以此篇为证，2025&#x2F;8&#x2F;25 22:32 开始，这篇博客绝对会发扬光大！</p>]]></content>
      
      
      <categories>
          
          <category> 博客历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC420经历</title>
      <link href="/2025/08/25/ABC420%E7%BB%8F%E5%8E%86/"/>
      <url>/2025/08/25/ABC420%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>太好了，这次写了 ABCDEG，就差 F 就能 AK 了！<del>（这次题太水了）</del></p><h1 id="A-What-month-is-it"><a href="#A-What-month-is-it" class="headerlink" title="A - What month is it?"></a>A - What month is it?</h1><p>求 $X$ 月往后 $Y$ 月是几月。</p><p>有周期，直接对 $12$ 取模。但月份是 $[1,12]$，余数是 $[0,11]$，平移一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;(x+y<span class="number">-1</span>)%<span class="number">12</span><span class="number">+1</span>;</span><br></pre></td></tr></table></figure><h1 id="B-Most-Minority"><a href="#B-Most-Minority" class="headerlink" title="B - Most Minority"></a>B - Most Minority</h1><p>这题我读题读了10分钟，总共做了20分钟……所以我决定提供最好的题意。</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>$N$ 个人（奇数）投了 $M$ 轮票，每一行给你每个人投的共 $M$ 轮票（$0$ 或 $1$），求得分最高的人，若有同分升序输出。</p><p>得分规则：设一轮票中，有 $x$ 人投 $0$，$y$ 人投 $1$</p><ul><li>$x&#x3D;0$ 或 $y&#x3D;0$，所有人得 $1$ 分</li><li>$x&lt;y$，投 $0$ 得一分</li><li>$x&gt;y$，投 $1$ 得一分</li><li>由于 $N$ 是奇数，不存在 $x&#x3D;y$</li></ul><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>数据范围很小，枚举即可。值得注意的就是竖着一列才是一轮！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;0&#x27;</span>) x++;</span><br><span class="line">        <span class="keyword">else</span> y++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>||y==<span class="number">0</span>) <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;0&#x27;</span>) p[i]++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;1&#x27;</span>) p[i]++;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x=*<span class="built_in">max_element</span>(p<span class="number">+1</span>,p+n<span class="number">+1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(p[i]==x) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br></pre></td></tr></table></figure><h1 id="C-Sum-of-Min-Query"><a href="#C-Sum-of-Min-Query" class="headerlink" title="C - Sum of Min Query"></a>C - Sum of Min Query</h1><p>给你长度为 $N$ 的数组 $A$ 和 $B$，$Q$ 次查询，每次输入 $A&#x2F;B,X,V$，将 $A_X&#x2F;B_X$ 改为 $V$，再输出 $\sum_{i&#x3D;1}^n min(A_i,B_i)$。</p><p>每次查询对比原本的值更新即可，记得开 long long。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> x,v;</span><br><span class="line">cin&gt;&gt;ch&gt;&gt;x&gt;&gt;v;</span><br><span class="line"><span class="type">int</span> k=<span class="built_in">min</span>(a[x],b[x]);</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">&#x27;A&#x27;</span>) a[x]=v;</span><br><span class="line"><span class="keyword">else</span> b[x]=v;</span><br><span class="line">sum+=<span class="built_in">min</span>(a[x],b[x])-k;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br></pre></td></tr></table></figure><h1 id="D-Toggle-Maze"><a href="#D-Toggle-Maze" class="headerlink" title="D - Toggle Maze"></a>D - Toggle Maze</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>一个 $N\times M$的地图，其中 $A_{i,j}$ 有如下情况：</p><ul><li>. : 请输入文本</li><li># : 障碍</li><li>S : 起点</li><li>G : 终点</li><li>o : 门（开）</li><li>x : 门（关）</li><li>? : 开关（碰到时可让全图的门切换状态）</li></ul><p>从起点上下左右走，求到终点最小步数。</p><h2 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h2><p>一眼 bfs，多加一个状态表示开关，只会有两种，用 bool 表示，碰到开关取反，碰到门判断状态是否符合即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>;</span><br><span class="line"><span class="type">int</span> n,m,dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,dis[N][N][<span class="number">2</span>],sx,sy;</span><br><span class="line"><span class="type">char</span> a[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">bool</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;sx,sy,<span class="number">0</span>&#125;);</span><br><span class="line">    dis[sx][sy][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>().x,y=q.<span class="built_in">front</span>().y;</span><br><span class="line">        <span class="type">bool</span> f=q.<span class="built_in">front</span>().f;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(a[x][y]==<span class="string">&#x27;G&#x27;</span>) <span class="keyword">return</span> dis[x][y][f];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> nx=x+dx[i],ny=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">char</span> ch=a[nx][ny];</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>||(ch==<span class="string">&#x27;x&#x27;</span>&amp;&amp;!f)||(ch==<span class="string">&#x27;o&#x27;</span>&amp;&amp;f)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">bool</span> nf=f;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;?&#x27;</span>) nf=!f;</span><br><span class="line">            <span class="keyword">if</span>(dis[nx][ny][nf]==<span class="number">-1</span>)&#123;</span><br><span class="line">                dis[nx][ny][nf]=dis[x][y][f]<span class="number">+1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;nx,ny,nf&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;S&#x27;</span>) sx=i,sy=j;</span><br><span class="line">            dis[i][j][<span class="number">0</span>]=dis[i][j][<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">bfs</span>();</span><br><span class="line">    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="E-Reachability-Query"><a href="#E-Reachability-Query" class="headerlink" title="E - Reachability Query"></a>E - Reachability Query</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个 $N$ 个点的无向图，初始每个点都是白色，没有连边。$Q$ 个询问：</p><ul><li>类型 $1$，$u$和$v$ 之间连边</li><li>类型 $2$，将 $v$ 变色</li><li>类型 $3$，询问 $v$ 能否到达黑点</li></ul><h2 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h2><p>判断连通性，一眼并查集。</p><p>接下来考虑如何处理变色，我们可以开一个数组 $cnt$，$cnt_i$表示以 $i$ 为祖宗的联通块的黑点的个数。</p><p>$u$ 变色时，若该点原是黑色，则 $cnt_{find(u)}$ 减一，反则加一。</p><p>合并 $u,v$ 时，将 $cnt$ 也转移即可。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,q,fa[N],cnt[N];</span><br><span class="line"><span class="type">bool</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]));&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y) fa[x]=y,cnt[y]+=cnt[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(f[x]) cnt[fx]--;</span><br><span class="line">    <span class="keyword">else</span> cnt[fx]++;</span><br><span class="line">    f[x]=!f[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    <span class="type">int</span> op,u,v;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            <span class="built_in">merge</span>(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;u);</span><br><span class="line">            <span class="built_in">change</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;u);</span><br><span class="line">            <span class="keyword">if</span>(cnt[<span class="built_in">find</span>(u)]) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="G-sqrt-n²-n-X"><a href="#G-sqrt-n²-n-X" class="headerlink" title="G - sqrt(n²+n+X)"></a>G - sqrt(n²+n+X)</h1><p>当当当当！本次主角大水数学题登场！</p><p>这次 ABC，前 5 题很简单，F 一看就码量很大没敢写。于是，我就在茫茫人海中找到的这个标题直白的 G题——</p><p>发现很水，当然能让我做出来最好。</p><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定 $x$，求能使 $\sqrt{n^2+n+x}$ 是整数的所有整数 $n$，升序输出。</p><h2 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h2><p>一眼数学（这次比赛怎么这么多一眼）。</p><p>设 $\sqrt{n^2+n+x}&#x3D;k$<br>$$\therefore n^2+n+x&#x3D;k^2$$<br>配一下方<br>$$（n+\frac{1}{2})^2+(x-\frac{1}{4})&#x3D;k^2$$<br>$$(2n+1)^2+(4x-1)&#x3D;(2k)^2$$<br>$$4x-1&#x3D;(2k)^2-(2n+1)^2&#x3D;(2k+2n+1)(2k-2n-1)$$<br>令 $a&#x3D;(2k+2n+1),b&#x3D;(2k-2n-1)$，则：<br>$$\begin{cases} ab&#x3D;4x-1 \newline a-b&#x3D;4n+2<br>\end{cases}$$<br>$$\therefore n&#x3D;\frac{a-b-2}{4} ,①$$</p><p>那我们枚举一一下 $4x-1$ 的因数，再带入 ① 判断一下能否整除，求出 $n$ 即可，注意负数也要考虑。时间复杂度 $O(\sqrt n)$，常数略大。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x,k;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a*b==k&amp;&amp;(a-b<span class="number">-2</span>)%<span class="number">4</span>==<span class="number">0</span>) ans.<span class="built_in">insert</span>((a-b<span class="number">-2</span>)/<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    k=<span class="number">4</span>*x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=<span class="built_in">abs</span>(k);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k%i!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">f</span>(i,k/i),<span class="built_in">f</span>(-i,-k/i);</span><br><span class="line">        <span class="built_in">f</span>(i,-k/i),<span class="built_in">f</span>(-i,k/i);</span><br><span class="line">        <span class="built_in">f</span>(k/i,i),<span class="built_in">f</span>(-k/i,i);</span><br><span class="line">        <span class="built_in">f</span>(k/i,-i),<span class="built_in">f</span>(-k/i,-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:ans) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,i);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> 题解 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 信息 </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
