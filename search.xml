<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>生日快乐，公主殿下！</title>
      <link href="/2025/08/31/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%EF%BC%8C%E5%85%AC%E4%B8%BB%E6%AE%BF%E4%B8%8B%EF%BC%81/"/>
      <url>/2025/08/31/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%EF%BC%8C%E5%85%AC%E4%B8%BB%E6%AE%BF%E4%B8%8B%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>今天是初音生日，请大家看看我的 cos 视频吧！</p><video src="https://tc-new.z.wiki/autoupload/f/EWB9z1VeWPAhbCMNJEaASdiO_OyvX7mIgxFBfDMDErs/20250831/YKE1/fsct.mp4" autoplay="true" controls="controls" width="50%" height="50%"></video><p>今天也是初三的第一天，结果考了一天的试，好惨哦（；´д｀）ゞ<br>本来想把班级的门关起来，强制每个同学看我的视频100遍再放学的。<br>生日快乐，公主殿下！有空我去补一补跟初音的故事。</p>]]></content>
      
      
      <categories>
          
          <category> 杂事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构一</title>
      <link href="/2025/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/"/>
      <url>/2025/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构一"><a href="#数据结构一" class="headerlink" title="数据结构一"></a>数据结构一</h1><p>本分类仅供复习、整理模板使用，不适用于第一次学。<br>与树有关的数据结构：</p><ul><li>并查集</li><li>ST表</li><li>树状数组 </li><li>线段树</li></ul><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><em><strong>并查集能 O(1) 的找到点的集合，我遍历所有却仍旧没有找到归属</strong></em></p><h3 id="用途及要求"><a href="#用途及要求" class="headerlink" title="用途及要求"></a>用途及要求</h3><p>判断连通性（所属集合），支持合并和查询。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>$fa_x$ 表示 $x$ 节点的父亲，可以构建出一个森林。同根的两点在同一集合内。若 $x$ 是根则 $fa_x&#x3D;x$<br>合并 $x,y$：令 $x$ 的根是 $y$ 的根的父亲。<br>查询：递归 $fa_x$ 至 $fa_x&#x3D;x$，即寻找所在的树的根。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>路径压缩最坏 $O(\log n)$，路径压缩+启发式合并接近 $O(1)$。一般只使用路径压缩即可。初始化 $fa_x&#x3D;x, sz_x&#x3D;1$</p><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y) fa[x]=y;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="路径压缩-启发式合并"><a href="#路径压缩-启发式合并" class="headerlink" title="路径压缩+启发式合并"></a>路径压缩+启发式合并</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(sz[x]&gt;sz[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    fa[x]=y,sz[y]+=sz[x];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><p><em><strong>即使是倍增的去接近你，我也需要你能忍受我的反复才能相遇<br>否则无论思念如何重复，我也找不回你的答案</strong></em></p><h3 id="用途及要求-1"><a href="#用途及要求-1" class="headerlink" title="用途及要求"></a>用途及要求</h3><p>查询任意区间 $[L,R]$的值，需要满足<strong>可重复计算贡献</strong><br>即 $x&#x3D;cal(x,x)$，如 max, min, 按位与, 按位或, lca……</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>倍增思想，类似 LCA 中求 $fa$<br>$st_{i,j}$ 表示左端点为 $i$，长度为 $2^j$ 的区间的值。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>预处理后不可修改。预处理 $O(n\log n)$，查询 $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) st[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;len)&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+(<span class="number">1</span>&lt;&lt;len)<span class="number">-1</span>&lt;=n;l++)</span><br><span class="line">            st[l][len]=<span class="built_in">max</span>(st[l][len<span class="number">-1</span>],st[l+(<span class="number">1</span>&lt;&lt;len<span class="number">-1</span>)][len<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="built_in">log</span>(r-l<span class="number">+1</span>)/<span class="built_in">log</span>(<span class="number">2.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)<span class="number">+1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p><em><strong>有了线段树，你还会爱我吗?<br>会的。我们只是正常朋友关系。<br>可她比我全能，要求比我少，心思比我更好想！<br>不要再多虑了，你的常数和码量都是她无法比拟的。<br>还有，你是我心中那个只会单点修改的小傻瓜啊</strong></em></p><h3 id="用途及要求-2"><a href="#用途及要求-2" class="headerlink" title="用途及要求"></a>用途及要求</h3><p>基础：单点修改+区间查询<br>扩展：区间修改+查询<br>树状数组维护的信息及运算要满足<strong>结合律</strong>且<strong>可差分</strong>的。（OI-wiki）<br>如区间和、区间乘、区间异或。</p><h3 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>原理类似线段树，对半分为很多个小区间，但发现有的区间是可以通过大减小等方式又由其他区间计算而得，可以删去。剩下的区间找规律，发现：$tr_i$ 表示以 $i$ 为右边界，长度为 <code>lowbit(i)=i&amp;-i</code> 的区间和。这样可以计算出任何 $[1,i]$ 的值。</p><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>原版支持单点修改+区间查询，复杂度均为 $O(\log n)$<br>搭配差分即可实现区间修改+单点查询。<br>实现比线段树简单，常数比线段树小，原理比线段树复杂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;tr[i]+=x;i+=i&amp;-i;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i)&#123;res+=tr[i];i-=i&amp;-i;&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h4><p>这时候就有聪明的小朋友要问了：那我要是想既能区间修改，又能区间查询呢？<br><del>直接线段树</del><br>查询总比修改简单，所以我们在差分后能区间修改的树状数组基础上改，考虑区间查询。<br>设原数组 $a$，差分数组 $d$，区间和 $sum$，则有：<br>$$a_i&#x3D;\sum_{j&#x3D;1}^id_j$$<br>$$sum_k&#x3D;\sum_{i&#x3D;1}^ka_i&#x3D;\sum_{i&#x3D;1}^k\sum_{j&#x3D;1}^id_j$$</p><h5 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h5><p>$$\sum_{i&#x3D;1}^k\sum_{j&#x3D;1}^id_j&#x3D;\sum_{j&#x3D;1}^k\sum_{i&#x3D;j}^kd_j&#x3D;\sum_{j&#x3D;1}^kd_j\times(k-j+1)$$</p><h5 id="解法2："><a href="#解法2：" class="headerlink" title="解法2："></a>解法2：</h5><p>$a_1&#x3D;d_1$<br>$a_2&#x3D;d_1+d_2$<br>$a_3&#x3D;d_1+d_2+d_3$<br>$\dots$<br>$a_k&#x3D;d_1+d_2+d_3+\dots+d_k$<br>不难发现，对 $a$ 求和的话（即竖着加），$d_j$ 出现了 $k-j+1$ 次，结果同解法1。<br>$$sum_k&#x3D;\sum_{j&#x3D;1}^kd_j\times(k-j+1)&#x3D;(k+1)\sum_{j&#x3D;1}^kd_j-\sum_{j&#x3D;1}^kd_j\times j$$<br>其中 $k$ 是定值，我们发现令 $b_j&#x3D;d_j\times j$ 的话，两个求和都可以分别用 $d$ 和 $b$ 的树状数组查询，那么 $sum$ 就可求了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=i; </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        tr1[i]+=x,tr2[i]+=x*k; </span><br><span class="line">        i+=i&amp;-i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(l,x);<span class="built_in">add</span>(r<span class="number">+1</span>,-x);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,k=i;</span><br><span class="line">    <span class="keyword">while</span>(i)&#123;</span><br><span class="line">        res+=(k<span class="number">+1</span>)*tr1[i]-tr2[i];</span><br><span class="line">        i-=i&amp;-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(r)-<span class="built_in">query</span>(l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（函数名重复？引用名言：<em>参数不一样~</em> ）</p><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p><em><strong>树状数组，你听我解释！！！<br>即使是万能的线段树，也无法维护你我之间的关系。因为，我们的联系不容得懒惰的标记。</strong></em></p><h3 id="用途及要求-3"><a href="#用途及要求-3" class="headerlink" title="用途及要求"></a>用途及要求</h3><p>请输入文本<br>基本啥区间信息都能维护，就是难写。能区间修改，区间查询。</p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>建树 $O(n)$，查询和修改 $O(\log n)$，常数出了名的大，容易被卡。<br>卡常：喜欢无脑写线段树的小朋友你们好啊，我是卡常，老老实实给我写树状数组或其他方法去吧。</p><h3 id="普通线段树-懒惰标记"><a href="#普通线段树-懒惰标记" class="headerlink" title="普通线段树+懒惰标记"></a>普通线段树+懒惰标记</h3><p>基本只用修改 tag 函数，其他地方很容易改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls o&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs o&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> val,lzy;<span class="comment">//维护的值和懒惰标记</span></span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> o)</span></span>&#123;</span><br><span class="line">    <span class="comment">//更新父节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tag</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="comment">/*标记*/</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//打标记+更新值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//更新子节点</span></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">tag</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">tag</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="comment">//重置标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[o].sum=a[l];<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(o);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        <span class="built_in">tag</span>(o,l,r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(o,l,r);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) <span class="built_in">update</span>(ls,l,mid,L,R);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) <span class="built_in">update</span>(rs,mid<span class="number">+1</span>,r,L,R);</span><br><span class="line">    <span class="built_in">pushup</span>(o); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) <span class="keyword">return</span> tr[o].val;</span><br><span class="line">    <span class="built_in">pushdown</span>(o,l,r);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) res+=<span class="built_in">query</span>(ls,l,mid,L,R);<span class="comment">//合并区间值</span></span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) res+=<span class="built_in">query</span>(rs,mid<span class="number">+1</span>,r,L,R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态开点"><a href="#动态开点" class="headerlink" title="动态开点"></a>动态开点</h3>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 总结 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP综合</title>
      <link href="/2025/08/27/DP%E7%BB%BC%E5%90%88/"/>
      <url>/2025/08/27/DP%E7%BB%BC%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="DP综合"><a href="#DP综合" class="headerlink" title="DP综合"></a>DP综合</h1><p>DP（Dynamic Programming），又称动态规划，<del>就是动态地进行规划</del>。<br>正式定义：通过把复杂问题分解为简单的<strong>子问题</strong>来求解的方法，并不是指某种具体的算法。用来解决的问题具有 <strong>最优子结构，无后效性，重叠子问题</strong> 这三种特性。<br>个人理解：高级的递推，用已知解去更新未知解。也是区分蒟蒻和巨佬的重要手段。同时用途极广，和数学中的数列一样，可以结合其他知识点出很难的题。<br>关键步骤：</p><ul><li>设计<strong>状态</strong>（将原问题分解为子问题）</li><li>推导<strong>状态转移方程</strong></li><li>按顺序实现<strong>状态转移</strong></li></ul><p>状态转移实现：递推（循环）   递归（<strong>记忆化搜索</strong>）<br>接下来介绍几种常见的模型。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>线性 DP<ul><li>背包 DP</li><li>区间 DP</li><li>LCA</li></ul></li><li>树形 DP<ul><li>普通树形</li><li>换根 DP</li></ul></li><li>状压 DP</li><li>数位 DP</li></ul><h2 id="线性-DP"><a href="#线性-DP" class="headerlink" title="线性 DP"></a>线性 DP</h2><p>最基础的一类 DP，线性的进行状态转移。</p><h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><p>经典 DP 模型。</p><h4 id="引入（01背包）"><a href="#引入（01背包）" class="headerlink" title="引入（01背包）"></a>引入（01背包）</h4><p>$N$ 个物品，第 $i$ 个物品的重量 $w_i$，价值 $v_i$，以及背包总容量 $W$，最大化能取的物品的价值。<br>定义 $dp_{i,j}$ 为前 $i$ 个物品，占用了 $j$ 的容量的最大价值。转移方程：<br>$$dp_{i,j}&#x3D;max{dp_{i-1,j-w_i}+v_i}$$</p><h4 id="滚动数组空间优化"><a href="#滚动数组空间优化" class="headerlink" title="滚动数组空间优化"></a>滚动数组空间优化</h4><p>注意到 dp 数组的空间复杂度为 $O(NW)$，很大。又发现每次 $dp_i$ 只用 $dp_{i-1}$ 转移，可以直接把这一维度优化掉，但循环顺序要改变。</p><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举物品 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=W;j&gt;=w[i];j--)<span class="comment">//枚举体积</span></span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举物品 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=w[i];j&lt;=W;j++)<span class="comment">//枚举体积</span></span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure><h2 id="树形DP-简介"><a href="#树形DP-简介" class="headerlink" title="树形DP 简介"></a>树形DP 简介</h2><p>顾名思义，就是在树上进行 DP。由于树的递归性质，通常的写法就是在 dfs 遍历树时进行状态转移。<br><br>通常，$dp_u$ 状态一般都为以 $u$ 为根的子树的最优解。先 dfs 遍历子树的所有最优解，然后向上传递给子树的父节点来转移，最终根节点的值即为所求的最优解（当然也有向下转移的）。</p><h2 id="换根DP"><a href="#换根DP" class="headerlink" title="换根DP"></a>换根DP</h2><p>上述的普通树形 DP 只能求解一个固定点为根，若是要枚举每一个根，岂不是得 $O(n^2)$ ？<br>非也非也，我们发现相邻的节点作为根，树除了他们俩本身基本不会有啥变化，因此换根的时候只有修改他俩的 DP 值就好了，复杂度 $O(n)$。就会有以下神板，只需推出一个转移式即可：</p><h3 id="模板1"><a href="#模板1" class="headerlink" title="模板1"></a>模板1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])</span><br><span class="line">        <span class="keyword">if</span>(v!=pre) <span class="built_in">dfs1</span>(v,u),<span class="comment">/*v对u转移;*/</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uv</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">//v对u还原 </span></span><br><span class="line">    <span class="comment">//u对v转移 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>&#123;</span><br><span class="line">    <span class="comment">//此时dp[u]的值就是u作为根 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])</span><br><span class="line">        <span class="keyword">if</span>(v!=pre) <span class="built_in">uv</span>(u,v),<span class="built_in">dfs2</span>(v,u),<span class="built_in">uv</span>(v,u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 总结 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 模板 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC419E题解</title>
      <link href="/2025/08/26/ABC419E%E9%A2%98%E8%A7%A3/"/>
      <url>/2025/08/26/ABC419E%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>有点耻辱，打比赛的时候去吃饭了，最后赛后 20 分钟就把 E 题写出来了……还给我掉了分╥﹏╥…<del>又被 ABC 做局了。</del></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>  给定长为 $N$ 的整数序列，每次操作可以将单个元素加一，求至少多少次操作，使得每个长为 $L$ 的子段和为 $M$ 的倍数。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>让每个固定长度的子段和为一个数的倍数……这一眼就很数学，或者说很有规律啊。我们发现，如果有<br>$$\sum_{i&#x3D;k}^{k+L-1}a_i\equiv \sum_{i&#x3D;k+1}^{k+L}a_i\equiv0\pmod{M}$$<br>那恒等式两边减去公共部分 $\sum_{i&#x3D;k+1}^{k+L-1}a_i$，就有<br>$$a_k\equiv a_{k+L}\pmod{M}$$<br>那我们就可以把每隔 $L$ 个的数分为一类，每类的数字对 $M$ 取模相同。那这样，我们只需要把前 $L$ 项的数算出，就可以用把剩下的都算出来了。</p><p>只用算前 $L$ 项，观察到 $L\leq N,M\leq500$，我们可以枚举每一项和前一项模 $M$ 的余数，就可使用动态规划进行状态转移（<del>一眼 dp</del>）。</p><p>令 $dp_{i,j}$ 表示使前 $i$ 项的和对 $M$ 取模为 $j$ 的最小操作数，$sum_{i,j}$ 表示把和 $i$ 同类的数对 $M$ 的余数都改为 $j$ 的最小操作数（ $sum$ 可以直接枚举算），那么转移式如下<br>$$ dp_{i, (j+k) mod \ M}&#x3D; \min (dp_{i-1,k}+sum_{i,j}) $$<br>其中 $k$ 表示前一项模 $M$ 的余数，$(j+k) mod \ M$ 表示这一项模 $M$ 的余数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>; </span><br><span class="line"><span class="type">int</span> n,m,l,a[N],ans,dp[N][N],sum; </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=l) </span><br><span class="line">            c[i].<span class="built_in">push_back</span>(a[j]); </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k:c[i]) sum+=(j-k+m)%m;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">                dp[i][(j+k)%m]=<span class="built_in">min</span>(dp[i][(j+k)%m],dp[i<span class="number">-1</span>][k]+sum);</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;dp[l][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> 题解 </tag>
            
            <tag> 同余 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC416E题解</title>
      <link href="/2025/08/26/ABC416E%E9%A2%98%E8%A7%A3/"/>
      <url>/2025/08/26/ABC416E%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>十年 OI 一场空，不开 long long 见祖宗。这是我第一次洛谷的官方题解。</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个 $N$ 个点，$M$ 条边的无向图，图中有 $K$ 个点有机场，有机场的点可以耗时 $T$ 时抵达另一个有机场的点。</p><p>有 $Q$ 个查询，分为 $3$ 种:加边、加机场、询问所有联通的点之间的最短距离之和。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>注意到 $N\leq500$，还要求最短路、加边，我们可以直接使用邻接矩阵存图，并用 Floyd 计算多源最短路。</p><p>使用 Floyd 进行加边操作很简单，假设加上了连接 $u,v$ 长度为 $w$ 的边，状态转移方程如下：</p><p>$$dis_{i,j}&#x3D;min{dis_{i,j},dis_{i,u}+w+dis_{v,j},dis_{i,v}+w+dis_{u,j}}$$</p><p>但是添加机场应该怎么处理呢？其实很简单（<del>虽然我在比赛的时候 D 没开 long long 调了好久导致E没时间</del>）。</p><p>可以<strong>添加一个虚点</strong> $N+1$，让这个点与所有有机场的点连接一条长为 $\frac{T}{2}$ 的边。有点新建机场时，只需让它与 $N+1$ 连边，即转化为加边操作，如上述方程转移即可。</p><p>为了避免浮点数一开始先将边权乘以 $2$，最后计算时再除以 $2$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>（上一题没开 long long 有阴影了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>;</span><br><span class="line"><span class="type">int</span> n,m,g[N][N],k,t;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">+1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n<span class="number">+1</span>;j++)</span><br><span class="line">            g[i][j]=<span class="built_in">min</span>(&#123;g[i][j],g[i][u]+w+g[v][j],g[i][v]+w+g[u][j]&#125;); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="type">int</span> inf=g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">+1</span>;i++) g[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        g[u][v]=g[v][u]=<span class="built_in">min</span>(g[u][v],w*<span class="number">2</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    cin&gt;&gt;k&gt;&gt;t;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;d),g[d][n<span class="number">+1</span>]=g[n<span class="number">+1</span>][d]=t; <span class="comment">//机场n+1 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">+1</span>;k++)<span class="comment">//floyd</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">+1</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n<span class="number">+1</span>;j++)</span><br><span class="line">                g[i][j]=<span class="built_in">min</span>(g[i][j],g[i][k]+g[k][j]);</span><br><span class="line">    <span class="type">int</span> q,op;</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> u,v,w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            <span class="built_in">add</span>(u,v,<span class="number">2</span>*w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">            <span class="built_in">add</span>(x,n<span class="number">+1</span>,t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                    <span class="keyword">if</span>(g[i][j]!=inf) tot+=g[i][j]/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,tot);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> 题解 </tag>
            
            <tag> 图论 </tag>
            
            <tag> Floyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环染色方案数</title>
      <link href="/2025/08/26/%E7%8E%AF%E6%9F%93%E8%89%B2%E6%96%B9%E6%A1%88%E6%95%B0/"/>
      <url>/2025/08/26/%E7%8E%AF%E6%9F%93%E8%89%B2%E6%96%B9%E6%A1%88%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个大小为 $n$ 的环，要求给环上每个节点染色为 $1 \sim k$ 中的某种颜色，使得任意两个相邻的节点颜色不同，询问染色的方案数。答案对 $10^9+7$ 取模。</p><h2 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h2><p>注意到 $n,k\leq10^9$，连数组都开不了，于是我们考虑数学（<del>还有数列大佬嘿嘿嘿</del>）。</p><p>定义 $A_n$ 表示染色方案数，如右图：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/o9aay657.png?x-oss-process=image/resize,m_lfit,h_170,w_225" alt="1"></p><ol><li>若 $1,n-1$ 不同色，方案数为 $(k-2)A_{n-1}$</li><li>若 $1,n-1$ 同色，方案数为 $(k-1)A_{n-2}$</li></ol><p>$$\therefore A_n&#x3D;(k-2)A_{n-1}+(k-1)A_{n-2}$$ </p><p>考虑到 $A_1&#x3D;k$ 不满足上式，令 $a_n&#x3D;A_{n+1},a_1&#x3D;k(k-1),a_2&#x3D;k(k-1)(k-2)$，也有：</p><p>$$a_n&#x3D;(k-2)a_{n-1}+(k-1)a_{n-2} \ ①$$ </p><p>熟悉的待定系数法，仿照斐波那契数列，设 $a_n+\mu a_{n-1}&#x3D;\lambda (a_{n-1}+\mu a_{n-2})\ ②$ </p><p>联立 $①②$，有  </p><p>$$\begin{cases} \lambda -\mu&#x3D;k-2 \newline \lambda\mu&#x3D;k-1<br>\end{cases}$$</p><p>很简单的方程，凑完全平方即可，取其中一个解</p><p>$$\begin{cases} \lambda&#x3D;k-1 \newline \mu&#x3D;1<br>\end{cases}$$</p><p>代入 $②$：$a_n+a_{n-1}&#x3D;(k-1)(a_{n-1}+a_{n-2})$</p><p>令 $b_n&#x3D;a_{n+1}+a_n$，则 $b_n&#x3D;(k-1)b_{n-1},b_1&#x3D;a_1+a_2&#x3D;k(k-1)^2$</p><p>$\therefore b$ 是以 $k(k-1)^2$ 为首项，$q&#x3D;(k-1)$ 的等比数列，$b_n&#x3D;b_1q^{n-1}&#x3D;k(k-1)^{n+1}$</p><p>$$\therefore a_{n+1}+a_n&#x3D;k(k-1)^{n+1} \ ③$$ </p><p>继续使用待定系数法，注意到 $n+1$ 出现在 $k$ 的指数上面，则对于 $a_n$ 也应该有个 $(k-1)^n$，即要多乘一个 $(k-1)$，于是设</p><p>$$a_{n+1}+m(k-1)&#x3D;-(a_n+m) \ ④$$ </p><p>联立 $③④$，解得 $m&#x3D;-(k-1)^{n+1}$</p><p>$$\therefore a_{n+1}-(k-1)^{n+2}&#x3D;-(a_n-(k-1)^{n+1})$$</p><p>令 $c_n&#x3D;a_n-(k-1)^{n+1}$，则 $c_n&#x3D;-c_{n-1},c_1&#x3D;a_1-(k-1)^2&#x3D;k-1$</p><p>$$\therefore c_n&#x3D;(k-1)\cdot(-1)^{n-1}$$</p><p>$$a_n&#x3D;(k-1)^{n+1}+(-1)^{n-1}\cdot(k-1)$$</p><p>$$A_n&#x3D;a_{n-1}&#x3D;(k-1)^n+(-1)^n(k-1)$$</p><p>收工！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>这本质上是个数学题，推出结论后就没什么难点了，唯一值得注意的地方是 $n\leq10^9$，直接暴力求幂肯定会超时，于是使用快速幂（<del>这就不用我讲了吧……</del>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>) r=r*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r%mod;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,k); </span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="built_in">pow</span>(k<span class="number">-1</span>,n)+((n&amp;<span class="number">1</span>)?(<span class="number">1</span>-k):(k<span class="number">-1</span>))+mod)%mod);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>我是不会告诉你我最后取模忘记先加上 $mod$，为此还调了半天的。</del></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC408E题解</title>
      <link href="/2025/08/26/ABC408E%E9%A2%98%E8%A7%A3/"/>
      <url>/2025/08/26/ABC408E%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>本题与这一道<a href="https://www.luogu.com.cn/problem/CF1624G">或最小生成树</a>思路一样，做完本题可以做这一道巩固一下。</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个连通无向图，求 $1$ 到 $n$ 的简单路径的边权之或的最小值。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>看到路径的最小值，首先想起最短路，用 dijkstra？但立即意识到不太行，并不是一个边权越大它与另个一个值按位或的值就会越大。</p><p>接下来以按位或的性质作为突破口。<strong>位运算中不同位是相对独立的</strong>，我们可以考虑从每一位枚举。</p><p><strong>如果答案的第 $i$ 位可以为 $0$，无论后面其它位是多少和都不会超过 $2^{i-1}$</strong>。 即若能取 $0$ 则永远比取 $1$ 优。所以我们从高位到低位贪心，尽量让高位不要取 $1$，如果可以取 $0$ 就取 $0$。</p><p>注意到数据范围 $0\leq w &lt;2^{30}$，枚举 $0\leq i \leq 30$。什么时候这一位必须要取 $1$ 呢？<strong>当只用这一位是 $0$，且前几位满足之前枚举的要求的边无法使 $1$ 与 $n$ 连通时，这一位就只能取 $1$ 了</strong>。</p><h3 id="举个例子-第一个样例："><a href="#举个例子-第一个样例：" class="headerlink" title="举个例子 第一个样例："></a>举个例子 第一个样例：</h3><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/sy0v69hz.png?x-oss-process=image/resize,m_lfit,h_200,w_400"></p><ul><li><p>当 $i&#x3D;2$ 时，我们去掉所有第 $3$ 位是 $1$ 的边，发现 $1$-&gt;$2$-&gt;$3$-&gt;$4$ 仍然可以到达，那我们就不取，$ans&#x3D;(000)_2$。</p></li><li><p>当 $i&#x3D;1$ 时，我们不仅不能取第 $2$ 位是 $1$的边，还要满足之前的条件，即第 $3$ 位是 $1$ 的不取。发现 $1$ 到不了 $4$ 了，于是这一位必须是 $1$，$ans&#x3D;(010)_2$。</p></li><li><p>当 $i&#x3D;0$ 时,和之前一样，但由于 $ans$ 第 $2$ 位已经取 $1$，我们可以取第 $2$ 位是 $1$的边。发现不连通，$ans&#x3D;(011)_2&#x3D;3$。</p></li></ul><h2 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h2><p>判断图联通可以用 bfs 等一系列方法，这里我采用并查集，并使用 $vis$ 数组判断该边可不可以使用。时间复杂度 $O((m+n)·\log(m))$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,m,fa[N],ans,num[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x==fa[x])?x:(fa[x]=<span class="built_in">find</span>(fa[x]));&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y) fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        e[i]=&#123;u,v,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">max</span>(n,m);i++) fa[i]=i,vis[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> cnt=n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(e[j].w&amp;(<span class="number">1</span>&lt;&lt;i))) <span class="built_in">merge</span>(e[j].u,e[j].v);<span class="comment">//这一位可以取</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(<span class="number">1</span>)==<span class="built_in">find</span>(n))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(e[j].w&amp;(<span class="number">1</span>&lt;&lt;i)) vis[j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ans+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) fa[j]=j;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> 题解 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC407E题解</title>
      <link href="/2025/08/26/ABC407E%E9%A2%98%E8%A7%A3/"/>
      <url>/2025/08/26/ABC407E%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>看到滑动窗口，很容易想到单调队列，但该做法在本题中时间复杂度达到了 $O(n^2)$，不可取，于是考虑计算每个元素在不同窗口的贡献。</p><p>首先，元素在哪些窗口会作为最大值？对于每一个 $i∈[1,n]$ 我们可以用<strong>单调栈</strong>预计算出左右两边第一个大于他的值，并得到其能向左&#x2F;右扩展多少步。同时为了避免重复计算贡献，我们使用左闭右开，即：</p><ul><li>向左找到最近的一个位置 $j$ 使得 $a_j\geq a_i$ （若不存在则为 $0$），则 $l_i&#x3D;i-j$</li><li>向右找到最近的一个位置 $j$ 使得 $a_j&gt;a_i$ （若不存在则为 $n+1$），则 $r_i&#x3D;j-i$</li></ul><hr><p>接下来分类讨论，计算贡献，记 $k$ 为滑动窗口的长度，$x&#x3D;min(l_i,r_i),y&#x3D;max(l_i,r_i)$，有：</p><ul><li>当 $k∈[1,x]$，对长度为 $k$ 的窗口有贡献的共有 $x$ 个，$ans_k&#x3D;ans_k+a_i k$</li><li>当 $k∈(x,y]$，对长度为 $k$ 的窗口有贡献的共有 $x$ 个，$ans_k&#x3D;ans_k+a_i x$</li><li>当$k∈(y,x+y)$，对长度为 $k$ 的窗口有贡献的共有 $(x+y-k)$ 个，$ans_k&#x3D;ans_k+(x+y-k) a_i$</li></ul><p>区间修改，单点查询，可以使用树状数组或者线段树，但最简单的还是差分。</p><p>维护 $p$，$q$ 差分数组，<strong>将上述操作含有 $k$ 的项归为 $p$，其余归为 $q$，答案 $ans_k&#x3D;\sum_{i&#x3D;1}^k p_i k+\sum_{i&#x3D;1}^k q_i$</strong></p><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],l[N],r[N];</span><br><span class="line"><span class="type">int</span> p[N],q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> *b,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;b[l]+=x,b[r<span class="number">+1</span>]-=x;&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;a[i]&gt;a[s.<span class="built_in">top</span>()]) s.<span class="built_in">pop</span>();</span><br><span class="line">        l[i]=i-(s.<span class="built_in">empty</span>()?<span class="number">0</span>:s.<span class="built_in">top</span>());</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) s.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;a[i]&gt;=a[s.<span class="built_in">top</span>()]) s.<span class="built_in">pop</span>();</span><br><span class="line">        r[i]=(s.<span class="built_in">empty</span>()?n<span class="number">+1</span>:s.<span class="built_in">top</span>())-i; </span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=l[i],y=r[i];</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y); </span><br><span class="line">        <span class="built_in">add</span>(p,<span class="number">1</span>,x,a[i]);</span><br><span class="line">        <span class="built_in">add</span>(q,x<span class="number">+1</span>,y,a[i]*x);</span><br><span class="line">        <span class="built_in">add</span>(p,y<span class="number">+1</span>,x+y,-a[i]);</span><br><span class="line">        <span class="built_in">add</span>(q,y<span class="number">+1</span>,x+y,a[i]*(x+y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        p[i]+=p[i<span class="number">-1</span>],q[i]+=q[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,p[i]*i+q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>蒟蒻第一次写题解，有格式不对请见谅，我会改进的QwQ。</p>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> 题解 </tag>
            
            <tag> 单调栈 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客「创世纪」</title>
      <link href="/2025/08/25/%E5%8D%9A%E5%AE%A2%E3%80%8C%E5%88%9B%E4%B8%96%E7%BA%AA%E3%80%8D/"/>
      <url>/2025/08/25/%E5%8D%9A%E5%AE%A2%E3%80%8C%E5%88%9B%E4%B8%96%E7%BA%AA%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="我的博客，终于启用了"><a href="#我的博客，终于启用了" class="headerlink" title="我的博客，终于启用了"></a>我的博客，终于启用了</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>经历了 4 天的调试，反反复复删了 2 次容器，花 15 块买了个域名 <a href="https://muyang.blog/">muyang.blog</a>，结果没钱升级所以服务不安全，暂时放弃了。能有现在的效果我已经很满意了。</p><p>我之后会持续在博客更新的，欢迎大家来观看！内容包括但不限于：</p><ul><li>数学&#x2F;信息知识分享</li><li>生活趣事（日记）</li><li>偶然灵感</li><li>看番、作品心得</li></ul><p>总之，以此篇为证，2025&#x2F;8&#x2F;25 22:32 开始，这篇博客绝对会发扬光大！</p>]]></content>
      
      
      <categories>
          
          <category> 博客历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC420经历</title>
      <link href="/2025/08/25/ABC420%E7%BB%8F%E5%8E%86/"/>
      <url>/2025/08/25/ABC420%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>太好了，这次写了 ABCDEG，就差 F 就能 AK 了！<del>（这次题太水了）</del></p><h1 id="A-What-month-is-it"><a href="#A-What-month-is-it" class="headerlink" title="A - What month is it?"></a>A - What month is it?</h1><p>求 $X$ 月往后 $Y$ 月是几月。</p><p>有周期，直接对 $12$ 取模。但月份是 $[1,12]$，余数是 $[0,11]$，平移一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;(x+y<span class="number">-1</span>)%<span class="number">12</span><span class="number">+1</span>;</span><br></pre></td></tr></table></figure><h1 id="B-Most-Minority"><a href="#B-Most-Minority" class="headerlink" title="B - Most Minority"></a>B - Most Minority</h1><p>这题我读题读了10分钟，总共做了20分钟……所以我决定提供最好的题意。</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>$N$ 个人（奇数）投了 $M$ 轮票，每一行给你每个人投的共 $M$ 轮票（$0$ 或 $1$），求得分最高的人，若有同分升序输出。</p><p>得分规则：设一轮票中，有 $x$ 人投 $0$，$y$ 人投 $1$</p><ul><li>$x&#x3D;0$ 或 $y&#x3D;0$，所有人得 $1$ 分</li><li>$x&lt;y$，投 $0$ 得一分</li><li>$x&gt;y$，投 $1$ 得一分</li><li>由于 $N$ 是奇数，不存在 $x&#x3D;y$</li></ul><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>数据范围很小，枚举即可。值得注意的就是竖着一列才是一轮！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;0&#x27;</span>) x++;</span><br><span class="line">        <span class="keyword">else</span> y++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>||y==<span class="number">0</span>) <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;0&#x27;</span>) p[i]++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;1&#x27;</span>) p[i]++;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x=*<span class="built_in">max_element</span>(p<span class="number">+1</span>,p+n<span class="number">+1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(p[i]==x) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br></pre></td></tr></table></figure><h1 id="C-Sum-of-Min-Query"><a href="#C-Sum-of-Min-Query" class="headerlink" title="C - Sum of Min Query"></a>C - Sum of Min Query</h1><p>给你长度为 $N$ 的数组 $A$ 和 $B$，$Q$ 次查询，每次输入 $A&#x2F;B,X,V$，将 $A_X&#x2F;B_X$ 改为 $V$，再输出 $\sum_{i&#x3D;1}^n min(A_i,B_i)$。</p><p>每次查询对比原本的值更新即可，记得开 long long。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> x,v;</span><br><span class="line">cin&gt;&gt;ch&gt;&gt;x&gt;&gt;v;</span><br><span class="line"><span class="type">int</span> k=<span class="built_in">min</span>(a[x],b[x]);</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">&#x27;A&#x27;</span>) a[x]=v;</span><br><span class="line"><span class="keyword">else</span> b[x]=v;</span><br><span class="line">sum+=<span class="built_in">min</span>(a[x],b[x])-k;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br></pre></td></tr></table></figure><h1 id="D-Toggle-Maze"><a href="#D-Toggle-Maze" class="headerlink" title="D - Toggle Maze"></a>D - Toggle Maze</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>一个 $N\times M$的地图，其中 $A_{i,j}$ 有如下情况：</p><ul><li>. : 请输入文本</li><li># : 障碍</li><li>S : 起点</li><li>G : 终点</li><li>o : 门（开）</li><li>x : 门（关）</li><li>? : 开关（碰到时可让全图的门切换状态）</li></ul><p>从起点上下左右走，求到终点最小步数。</p><h2 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h2><p>一眼 bfs，多加一个状态表示开关，只会有两种，用 bool 表示，碰到开关取反，碰到门判断状态是否符合即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>;</span><br><span class="line"><span class="type">int</span> n,m,dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,dis[N][N][<span class="number">2</span>],sx,sy;</span><br><span class="line"><span class="type">char</span> a[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">bool</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;sx,sy,<span class="number">0</span>&#125;);</span><br><span class="line">    dis[sx][sy][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>().x,y=q.<span class="built_in">front</span>().y;</span><br><span class="line">        <span class="type">bool</span> f=q.<span class="built_in">front</span>().f;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(a[x][y]==<span class="string">&#x27;G&#x27;</span>) <span class="keyword">return</span> dis[x][y][f];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> nx=x+dx[i],ny=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">char</span> ch=a[nx][ny];</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>||(ch==<span class="string">&#x27;x&#x27;</span>&amp;&amp;!f)||(ch==<span class="string">&#x27;o&#x27;</span>&amp;&amp;f)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">bool</span> nf=f;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;?&#x27;</span>) nf=!f;</span><br><span class="line">            <span class="keyword">if</span>(dis[nx][ny][nf]==<span class="number">-1</span>)&#123;</span><br><span class="line">                dis[nx][ny][nf]=dis[x][y][f]<span class="number">+1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;nx,ny,nf&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;S&#x27;</span>) sx=i,sy=j;</span><br><span class="line">            dis[i][j][<span class="number">0</span>]=dis[i][j][<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">bfs</span>();</span><br><span class="line">    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="E-Reachability-Query"><a href="#E-Reachability-Query" class="headerlink" title="E - Reachability Query"></a>E - Reachability Query</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个 $N$ 个点的无向图，初始每个点都是白色，没有连边。$Q$ 个询问：</p><ul><li>类型 $1$，$u$和$v$ 之间连边</li><li>类型 $2$，将 $v$ 变色</li><li>类型 $3$，询问 $v$ 能否到达黑点</li></ul><h2 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h2><p>判断连通性，一眼并查集。</p><p>接下来考虑如何处理变色，我们可以开一个数组 $cnt$，$cnt_i$表示以 $i$ 为祖宗的联通块的黑点的个数。</p><p>$u$ 变色时，若该点原是黑色，则 $cnt_{find(u)}$ 减一，反则加一。</p><p>合并 $u,v$ 时，将 $cnt$ 也转移即可。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,q,fa[N],cnt[N];</span><br><span class="line"><span class="type">bool</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]));&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y) fa[x]=y,cnt[y]+=cnt[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(f[x]) cnt[fx]--;</span><br><span class="line">    <span class="keyword">else</span> cnt[fx]++;</span><br><span class="line">    f[x]=!f[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    <span class="type">int</span> op,u,v;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            <span class="built_in">merge</span>(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;u);</span><br><span class="line">            <span class="built_in">change</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;u);</span><br><span class="line">            <span class="keyword">if</span>(cnt[<span class="built_in">find</span>(u)]) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="G-sqrt-n²-n-X"><a href="#G-sqrt-n²-n-X" class="headerlink" title="G - sqrt(n²+n+X)"></a>G - sqrt(n²+n+X)</h1><p>当当当当！本次主角大水数学题登场！</p><p>这次 ABC，前 5 题很简单，F 一看就码量很大没敢写。于是，我就在茫茫人海中找到的这个标题直白的 G题——</p><p>发现很水，当然能让我做出来最好。</p><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定 $x$，求能使 $\sqrt{n^2+n+x}$ 是整数的所有整数 $n$，升序输出。</p><h2 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h2><p>一眼数学（这次比赛怎么这么多一眼）。</p><p>设 $\sqrt{n^2+n+x}&#x3D;k$<br>$$\therefore n^2+n+x&#x3D;k^2$$<br>配一下方<br>$$（n+\frac{1}{2})^2+(x-\frac{1}{4})&#x3D;k^2$$<br>$$(2n+1)^2+(4x-1)&#x3D;(2k)^2$$<br>$$4x-1&#x3D;(2k)^2-(2n+1)^2&#x3D;(2k+2n+1)(2k-2n-1)$$<br>令 $a&#x3D;(2k+2n+1),b&#x3D;(2k-2n-1)$，则：<br>$$\begin{cases} ab&#x3D;4x-1 \newline a-b&#x3D;4n+2<br>\end{cases}$$<br>$$\therefore n&#x3D;\frac{a-b-2}{4} ,①$$</p><p>那我们枚举一一下 $4x-1$ 的因数，再带入 ① 判断一下能否整除，求出 $n$ 即可，注意负数也要考虑。时间复杂度 $O(\sqrt n)$，常数略大。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x,k;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a*b==k&amp;&amp;(a-b<span class="number">-2</span>)%<span class="number">4</span>==<span class="number">0</span>) ans.<span class="built_in">insert</span>((a-b<span class="number">-2</span>)/<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    k=<span class="number">4</span>*x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=<span class="built_in">abs</span>(k);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k%i!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">f</span>(i,k/i),<span class="built_in">f</span>(-i,-k/i);</span><br><span class="line">        <span class="built_in">f</span>(i,-k/i),<span class="built_in">f</span>(-i,k/i);</span><br><span class="line">        <span class="built_in">f</span>(k/i,i),<span class="built_in">f</span>(-k/i,i);</span><br><span class="line">        <span class="built_in">f</span>(k/i,-i),<span class="built_in">f</span>(-k/i,-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:ans) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,i);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> 题解 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 信息 </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
